<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SNode.C: detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SNode.C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacedetail.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1AppFriend.html">AppFriend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is simply to allow tests access to <a class="el" href="classApp.html" title="Creates a command line program, with very few defaults.">App</a>'s protected functions.  <a href="structdetail_1_1AppFriend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1element__type.html">element_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">not a pointer  <a href="structdetail_1_1element__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1element__type_3_01T_00_01typename_01std_1_1enable__if_3_01is__copyable__ptr_3_01523b2272a7e2fdb6b5ec55e56e958c09.html">element_type&lt; T, typename std::enable_if&lt; is_copyable_ptr&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1element__value__type.html">element_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1ExistingDirectoryValidator.html">ExistingDirectoryValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing directory (returns error message if check fails)  <a href="classdetail_1_1ExistingDirectoryValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1ExistingFileValidator.html">ExistingFileValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing file (returns error message if check fails)  <a href="classdetail_1_1ExistingFileValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1ExistingPathValidator.html">ExistingPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing path.  <a href="classdetail_1_1ExistingPathValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__find.html">has_find</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1IPV4Validator.html">IPV4Validator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the given string is a legal ipv4 address.  <a href="classdetail_1_1IPV4Validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for complex.  <a href="classdetail_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1is__istreamable.html">is_istreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for input streamability.  <a href="classdetail_1_1is__istreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__mutable__container_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01type3cbefe3f62998090130d5dc7084b8516.html">is_mutable_container&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type, decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().clear()), decltype(std::declval&lt; T &gt;().insert(std::declval&lt; decltype(std::declval&lt; T &gt;().end())&gt;(), std::declval&lt; const typename T::value_type &amp; &gt;()))&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__readable__container.html">is_readable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__readable__container_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01dec19493ce16a9a958c1a9c08fcab0b917c.html">is_readable_container&lt; T, conditional_t&lt; false, void_t&lt; decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().begin())&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__wrapper_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01typename_01T_1_3cdab8a3447131bfdab07dcebb242dc4.html">is_wrapper&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1NonexistentPathValidator.html">NonexistentPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an non-existing path.  <a href="classdetail_1_1NonexistentPathValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1pair__adaptor.html">pair_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for set-like structure: This just wraps a normal container in a few utilities that do almost nothing.  <a href="structdetail_1_1pair__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1pair__adaptor_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01typename_01T_3bf79cae463e1d5562874a40375cd28a.html">pair_adaptor&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type::first_type, typename T::value_type::second_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1subtype__count.html">subtype_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of overloads to get the type size of an object.  <a href="structdetail_1_1subtype__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1subtype__count__min.html">subtype_count_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declare the <a class="el" href="structdetail_1_1subtype__count__min.html" title="forward declare the subtype_count_min structure">subtype_count_min</a> structure  <a href="structdetail_1_1subtype__count__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count.html">type_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="structdetail_1_1type__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__complex_3_01T_01_4_1_1value_01_4_1_1type_01_4.html">type_count&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for complex since it sometimes looks like a wrapper.  <a href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__complex_3_01T_01_4_1_1value_01_4_1_1type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutable__container_32743c5a586dfe46e5bf0c7c2d6a42472.html">type_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size of types that are wrappers,except complex and tuples(which can also be wrappers sometimes)  <a href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutable__container_32743c5a586dfe46e5bf0c7c2d6a42472.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__wrapper_3_01T_01_4_15376f17be8887997560745d694dc9555.html">type_count&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size of types that are wrappers,except containers complex and tuples(which can also be wrappers sometimes)  <a href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__wrapper_3_01T_01_4_15376f17be8887997560745d694dc9555.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_01T_01_4_1_e1a9e3e949940e1dd113e756abea301f.html">type_count&lt; T, typename std::enable_if&lt;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structdetail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_01T_01_4_1_e1a9e3e949940e1dd113e756abea301f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="structdetail_1_1type__count__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutable__conta3aeab2d0875ed473372ecc06d988d44f.html">type_count_base&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type count base for containers is the <a class="el" href="structdetail_1_1type__count__base.html" title="This will only trigger for actual void type.">type_count_base</a> of the individual element.  <a href="structdetail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutable__conta3aeab2d0875ed473372ecc06d988d44f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__tuple__like_3_fb2355465138d1f65904a3ed34363060.html">type_count_base&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the base tuple size  <a href="structdetail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__tuple__like_3_fb2355465138d1f65904a3ed34363060.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_9is__tuple__like_3_0f73d166e02b87e6eeaa76e87fdb70337.html">type_count_base&lt; T, typename std::enable_if&lt;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structdetail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_9is__tuple__like_3_0f73d166e02b87e6eeaa76e87fdb70337.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1wrapped__type.html">wrapped_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to get the underlying value type if it exists or use a default  <a href="structdetail_1_1wrapped__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1wrapped__type_3_01T_00_01def_00_01typename_01std_1_1enable__if_3_01is__wrapper_386fe92118935402969e7eb52a19c29c3.html">wrapped_type&lt; T, def, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structdetail_1_1wrapped__type_3_01T_00_01def_00_01typename_01std_1_1enable__if_3_01is__wrapper_386fe92118935402969e7eb52a19c29c3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad86f32fac98b29b6cae34669baea3710" id="r_ad86f32fac98b29b6cae34669baea3710"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad86f32fac98b29b6cae34669baea3710">enabler</a> </td></tr>
<tr class="memdesc:ad86f32fac98b29b6cae34669baea3710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple empty scoped class.  <a href="#ad86f32fac98b29b6cae34669baea3710">More...</a><br /></td></tr>
<tr class="separator:ad86f32fac98b29b6cae34669baea3710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5100bdc7b136e623dd6ff2fa45f9560" id="r_ae5100bdc7b136e623dd6ff2fa45f9560"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560">path_type</a> { <a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560a357f5c155c9da6842b84ad1066996928">nonexistent</a>
, <a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac">file</a>
, <a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560a5f8f22b8cdbaeee8cf857673a9b6ba20">directory</a>
 }</td></tr>
<tr class="memdesc:ae5100bdc7b136e623dd6ff2fa45f9560"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCLI.html">CLI</a> enumeration of different file types.  <a href="#ae5100bdc7b136e623dd6ff2fa45f9560">More...</a><br /></td></tr>
<tr class="separator:ae5100bdc7b136e623dd6ff2fa45f9560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030bd2eaf73be4d81664d2ca703f7001" id="r_a030bd2eaf73be4d81664d2ca703f7001"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001">Classifier</a> { <br />
&#160;&#160;<a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001a2b1681c49e27b242d19b93c5c3620cb6">POSITIONAL_MARK</a>
, <a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001aa35c2b02966b1563e5bf7b81b8b0cf77">SHORT</a>
, <a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001ac1fabfea54ec6011e694f211f3ffebf3">LONG</a>
, <br />
&#160;&#160;<a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001a0693f2b4d4f0740bc76a2d65566b4fda">WINDOWS_STYLE</a>
, <a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001ac4fb22412f02354dbe5574e37caf50a7">SUBCOMMAND</a>
, <a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001ab447b0bfeb6e4502fb6a0c4223fb8d00">SUBCOMMAND_TERMINATOR</a>
<br />
 }</td></tr>
<tr class="separator:a030bd2eaf73be4d81664d2ca703f7001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad66dfe1973db05decb48edb0db5ac8e9" id="r_ad66dfe1973db05decb48edb0db5ac8e9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; <a class="el" href="classdetail_1_1is__istreamable.html">is_istreamable</a>&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ad66dfe1973db05decb48edb0db5ac8e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad66dfe1973db05decb48edb0db5ac8e9">from_stream</a> (const std::string &amp;istring, T &amp;obj)</td></tr>
<tr class="memdesc:ad66dfe1973db05decb48edb0db5ac8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated operation to get a value from a stream.  <br /></td></tr>
<tr class="separator:ad66dfe1973db05decb48edb0db5ac8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf2ca1139f2ebed02bdfd71de954815" id="r_aacf2ca1139f2ebed02bdfd71de954815"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_convertible&lt; T, std::string &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:aacf2ca1139f2ebed02bdfd71de954815"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacf2ca1139f2ebed02bdfd71de954815">to_string</a> (T &amp;&amp;value) -&gt; decltype(std::forward&lt; T &gt;(value))</td></tr>
<tr class="memdesc:aacf2ca1139f2ebed02bdfd71de954815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (directly forward if this can become a string)  <br /></td></tr>
<tr class="separator:aacf2ca1139f2ebed02bdfd71de954815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a646f04f5f3a4daecc475404a93fb5" id="r_a93a646f04f5f3a4daecc475404a93fb5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a93a646f04f5f3a4daecc475404a93fb5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93a646f04f5f3a4daecc475404a93fb5">to_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a93a646f04f5f3a4daecc475404a93fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from the object.  <br /></td></tr>
<tr class="separator:a93a646f04f5f3a4daecc475404a93fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af260ade0bc2785a1cad438e74e84c665" id="r_af260ade0bc2785a1cad438e74e84c665"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__ostreamable.html">is_ostreamable</a>&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af260ade0bc2785a1cad438e74e84c665"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af260ade0bc2785a1cad438e74e84c665">to_string</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:af260ade0bc2785a1cad438e74e84c665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (streaming must be supported for that type)  <br /></td></tr>
<tr class="separator:af260ade0bc2785a1cad438e74e84c665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93699cc852fd3794098ac36c4ee0881" id="r_af93699cc852fd3794098ac36c4ee0881"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_same&lt; T1, T2 &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af93699cc852fd3794098ac36c4ee0881"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af93699cc852fd3794098ac36c4ee0881">checked_to_string</a> (T &amp;&amp;value) -&gt; decltype(<a class="el" href="#aacf2ca1139f2ebed02bdfd71de954815">to_string</a>(std::forward&lt; T &gt;(value)))</td></tr>
<tr class="memdesc:af93699cc852fd3794098ac36c4ee0881"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <br /></td></tr>
<tr class="separator:af93699cc852fd3794098ac36c4ee0881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6841b0d6a5040a03f4ab1948c0641e4" id="r_af6841b0d6a5040a03f4ab1948c0641e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_same&lt; T1, T2 &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af6841b0d6a5040a03f4ab1948c0641e4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6841b0d6a5040a03f4ab1948c0641e4">checked_to_string</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:af6841b0d6a5040a03f4ab1948c0641e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <br /></td></tr>
<tr class="separator:af6841b0d6a5040a03f4ab1948c0641e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ed3e17654a22e52c65af40d1c99af7" id="r_aa8ed3e17654a22e52c65af40d1c99af7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_arithmetic&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:aa8ed3e17654a22e52c65af40d1c99af7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8ed3e17654a22e52c65af40d1c99af7">value_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa8ed3e17654a22e52c65af40d1c99af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string as a convertible value for arithmetic types  <br /></td></tr>
<tr class="separator:aa8ed3e17654a22e52c65af40d1c99af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9010bd9c361218bf65a0de139d8d3" id="r_a49a9010bd9c361218bf65a0de139d8d3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a49a9010bd9c361218bf65a0de139d8d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49a9010bd9c361218bf65a0de139d8d3">value_string</a> (const T &amp;value) -&gt; decltype(<a class="el" href="#aacf2ca1139f2ebed02bdfd71de954815">to_string</a>(value))</td></tr>
<tr class="memdesc:a49a9010bd9c361218bf65a0de139d8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">for other types just use the regular to_string function  <br /></td></tr>
<tr class="separator:a49a9010bd9c361218bf65a0de139d8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bec111d9f18677e64ece6787a824f21" id="r_a9bec111d9f18677e64ece6787a824f21"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:a9bec111d9f18677e64ece6787a824f21"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I==<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9bec111d9f18677e64ece6787a824f21">tuple_type_size</a> ()</td></tr>
<tr class="memdesc:a9bec111d9f18677e64ece6787a824f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 if the index &gt; tuple size  <br /></td></tr>
<tr class="separator:a9bec111d9f18677e64ece6787a824f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ef87849dccacec9ed8fef6604ba2cd" id="r_ae2ef87849dccacec9ed8fef6604ba2cd"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:ae2ef87849dccacec9ed8fef6604ba2cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I&lt; <a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type <a class="el" href="#a9bec111d9f18677e64ece6787a824f21">tuple_type_size</a>() { return <a class="el" href="structdetail_1_1subtype__count.html">subtype_count</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+<a class="el" href="#a9bec111d9f18677e64ece6787a824f21">tuple_type_size</a>&lt; T, I+1 &gt;();} template&lt; typename T &gt; struct <a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="#a9bec111d9f18677e64ece6787a824f21">tuple_type_size</a>&lt; T, 0 &gt;()};};template&lt; typename T &gt; struct <a class="el" href="structdetail_1_1subtype__count.html">subtype_count</a> { static constexpr int value{<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ? expected_max_vector_size :<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct type_count_min { static const int value{0};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="structdetail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename T::value_type &gt;::value};};template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I==<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return 0;} template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; <a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return <a class="el" href="structdetail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;();} template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size_min&lt; T, 0 &gt;()};};template&lt; typename T &gt; struct <a class="el" href="structdetail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr int value{<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ?((<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value&lt; expected_max_vector_size) ? <a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct expected_count { static const int value{0};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt; <a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_max_vector_size};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_count&lt; typename T::value_type &gt;::value};};enum class object_category :int { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, wstring_assignable=25, wstring_constructible=26, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80, };template&lt; typename T, typename Enable=void &gt; struct classify_object { static constexpr object_category value{object_category::other};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;!<a class="el" href="structis__bool.html">is_bool</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integral_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;!<a class="el" href="structis__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::unsigned_integral};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, char &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::char_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="structis__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::boolean_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::floating_point};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_assignable};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::wstring &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::wstring_assignable};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::wstring &gt;::value &amp;&amp;(<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::wstring &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::wstring_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::enumeration};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::complex_number};};template&lt; typename T &gt; struct uncommon_type { using type=typename std::conditional&lt; !std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::wstring &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::wstring &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type;static constexpr bool value=type::value;};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;(!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value{object_category::wrapper_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::number_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integer_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::double_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;((<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value &gt;=2 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value &gt;=2))&gt;::type &gt; { static constexpr object_category value{object_category::tuple_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::container_value};};template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::char_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;CHAR&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::integer_constructible, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;INT&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;UINT&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::floating_point||classify_object&lt; T &gt;::value==object_category::number_constructible||classify_object&lt; T &gt;::value==object_category::double_constructible, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;FLOAT&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::enumeration, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;ENUM&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;BOOLEAN&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::complex_number, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;COMPLEX&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp;classify_object&lt; T &gt;::value&lt;=object_category::other, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;TEXT&quot;;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; std::string type_name();template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; std::string type_name();template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value==1, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;();} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt; I==<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string{};} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt;(I&lt; <a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value), std::string &gt;::type tuple_name() { auto str=std::string{type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;()}+','+tuple_name&lt; T, I+1 &gt;();if(str.back()==',') str.pop_back();return str;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt; &gt; inline std::string type_name() { auto tname=std::string(1, '[')+tuple_name&lt; T, 0 &gt;();tname.push_back(']');return tname;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt; &gt; inline std::string type_name() { return type_name&lt; typename T::value_type &gt;();} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; bool integral_conversion(const std::string &amp;input, T &amp;output) noexcept { if(input.empty()||input.front()=='-') { return false;} char *val=nullptr;errno=0;std::uint64_t const output_ll=std::strtoull(input.c_str(), &amp;val, 0);if(errno==ERANGE) { return false;} output=static_cast&lt; T &gt;(output_ll);if(val==(input.c_str()+input.size()) &amp;&amp;static_cast&lt; std::uint64_t &gt;(output)==output_ll) { return true;} val=nullptr;std::int64_t const output_sll=std::strtoll(input.c_str(), &amp;val, 0);if(val==(input.c_str()+input.size())) { output=(output_sll&lt; 0) ? static_cast&lt; T &gt;(0) :static_cast&lt; T &gt;(output_sll);return(static_cast&lt; std::int64_t &gt;(output)==output_sll);} return false;} template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_signed&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2ef87849dccacec9ed8fef6604ba2cd">integral_conversion</a> (const std::string &amp;input, T &amp;output) noexcept</td></tr>
<tr class="memdesc:ae2ef87849dccacec9ed8fef6604ba2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively generate the tuple type name.  <br /></td></tr>
<tr class="separator:ae2ef87849dccacec9ed8fef6604ba2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6423843bf32523b1b9888e1708528e1" id="r_aa6423843bf32523b1b9888e1708528e1"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6423843bf32523b1b9888e1708528e1">to_flag_value</a> (std::string val)</td></tr>
<tr class="memdesc:aa6423843bf32523b1b9888e1708528e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a flag into an integer value typically binary flags.  <br /></td></tr>
<tr class="separator:aa6423843bf32523b1b9888e1708528e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482fea24f39f5d00bae6c530e5e2c5fc" id="r_a482fea24f39f5d00bae6c530e5e2c5fc"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a482fea24f39f5d00bae6c530e5e2c5fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a482fea24f39f5d00bae6c530e5e2c5fc">lexical_cast</a> (const std::string &amp;input, T &amp;output)</td></tr>
<tr class="memdesc:a482fea24f39f5d00bae6c530e5e2c5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer conversion.  <br /></td></tr>
<tr class="separator:a482fea24f39f5d00bae6c530e5e2c5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cdfb59576b0d3059bca113b6817da9" id="r_a53cdfb59576b0d3059bca113b6817da9"><td class="memTemplParams" colspan="2">template&lt;typename AssignTo , typename ConvertTo , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible||classify_object&lt; AssignTo &gt;::value==object_category::wstring_assignable||classify_object&lt; AssignTo &gt;::value==object_category::wstring_constructible), <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a53cdfb59576b0d3059bca113b6817da9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53cdfb59576b0d3059bca113b6817da9">lexical_assign</a> (const std::string &amp;input, AssignTo &amp;output)</td></tr>
<tr class="memdesc:a53cdfb59576b0d3059bca113b6817da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value through lexical cast operations.  <br /></td></tr>
<tr class="separator:a53cdfb59576b0d3059bca113b6817da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608a2cc4dd55857b6617e23aa3c2d7de" id="r_a608a2cc4dd55857b6617e23aa3c2d7de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a608a2cc4dd55857b6617e23aa3c2d7de">split_short</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;rest)</td></tr>
<tr class="separator:a608a2cc4dd55857b6617e23aa3c2d7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e23060ad5d66064604003ccb689f6" id="r_a763e23060ad5d66064604003ccb689f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a763e23060ad5d66064604003ccb689f6">split_long</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:a763e23060ad5d66064604003ccb689f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fae90768ee6ad45ccfc0c6e9ba4aabd" id="r_a4fae90768ee6ad45ccfc0c6e9ba4aabd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fae90768ee6ad45ccfc0c6e9ba4aabd">split_windows_style</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:a4fae90768ee6ad45ccfc0c6e9ba4aabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f81a352d3ebced093b357a351bd445" id="r_a89f81a352d3ebced093b357a351bd445"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89f81a352d3ebced093b357a351bd445">split_names</a> (std::string current)</td></tr>
<tr class="separator:a89f81a352d3ebced093b357a351bd445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c468291bac9f60305b1eca08693d306" id="r_a2c468291bac9f60305b1eca08693d306"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c468291bac9f60305b1eca08693d306">get_default_flag_values</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a2c468291bac9f60305b1eca08693d306"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract default flag values either {def} or starting with a !  <br /></td></tr>
<tr class="separator:a2c468291bac9f60305b1eca08693d306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d04a82cd217b4a6e2f16fac14d27778" id="r_a0d04a82cd217b4a6e2f16fac14d27778"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d04a82cd217b4a6e2f16fac14d27778">get_names</a> (const std::vector&lt; std::string &gt; &amp;input)</td></tr>
<tr class="memdesc:a0d04a82cd217b4a6e2f16fac14d27778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of short names, one of long names, and a single name.  <br /></td></tr>
<tr class="separator:a0d04a82cd217b4a6e2f16fac14d27778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a0f0282738a09f38981410f53200e9" id="r_a28a0f0282738a09f38981410f53200e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560">path_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a0f0282738a09f38981410f53200e9">check_path</a> (const char *<a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac">file</a>) noexcept</td></tr>
<tr class="memdesc:a28a0f0282738a09f38981410f53200e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type of the path from a file name  <br /></td></tr>
<tr class="separator:a28a0f0282738a09f38981410f53200e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548224c65306dc4738cb1837ef478d95" id="r_a548224c65306dc4738cb1837ef478d95"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; <a class="el" href="structis__copyable__ptr.html">is_copyable_ptr</a>&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a548224c65306dc4738cb1837ef478d95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a548224c65306dc4738cb1837ef478d95">smart_deref</a> (T value) -&gt; decltype(*value)</td></tr>
<tr class="separator:a548224c65306dc4738cb1837ef478d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384df3a85d5f165632c952a37d53ea15" id="r_a384df3a85d5f165632c952a37d53ea15"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!<a class="el" href="structis__copyable__ptr.html">is_copyable_ptr</a>&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a384df3a85d5f165632c952a37d53ea15"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference&lt; T &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a384df3a85d5f165632c952a37d53ea15">smart_deref</a> (T &amp;value)</td></tr>
<tr class="separator:a384df3a85d5f165632c952a37d53ea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05034c2e5e1b5764f22f1375cd9ade0" id="r_aa05034c2e5e1b5764f22f1375cd9ade0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa05034c2e5e1b5764f22f1375cd9ade0"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa05034c2e5e1b5764f22f1375cd9ade0">generate_set</a> (const T &amp;set)</td></tr>
<tr class="memdesc:aa05034c2e5e1b5764f22f1375cd9ade0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a set.  <br /></td></tr>
<tr class="separator:aa05034c2e5e1b5764f22f1375cd9ade0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e52836e0da48333684dc57febdf15d" id="r_a53e52836e0da48333684dc57febdf15d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53e52836e0da48333684dc57febdf15d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53e52836e0da48333684dc57febdf15d">generate_map</a> (const T &amp;map, bool key_only=false)</td></tr>
<tr class="memdesc:a53e52836e0da48333684dc57febdf15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a map.  <br /></td></tr>
<tr class="separator:a53e52836e0da48333684dc57febdf15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c0ee20a405b0ba24764e1e35120519" id="r_ad0c0ee20a405b0ba24764e1e35120519"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!<a class="el" href="structdetail_1_1has__find.html">has_find</a>&lt; T, V &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ad0c0ee20a405b0ba24764e1e35120519"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0c0ee20a405b0ba24764e1e35120519">search</a> (const T &amp;set, const V &amp;val) -&gt; std::pair&lt; bool, decltype(std::begin(<a class="el" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:ad0c0ee20a405b0ba24764e1e35120519"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function.  <br /></td></tr>
<tr class="separator:ad0c0ee20a405b0ba24764e1e35120519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f84ecdb9610a4e28f3bd4c5aac59c46" id="r_a6f84ecdb9610a4e28f3bd4c5aac59c46"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a6f84ecdb9610a4e28f3bd4c5aac59c46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f84ecdb9610a4e28f3bd4c5aac59c46">search</a> (const T &amp;set, const V &amp;val, const std::function&lt; V(V)&gt; &amp;filter_function) -&gt; std::pair&lt; bool, decltype(std::begin(<a class="el" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:a6f84ecdb9610a4e28f3bd4c5aac59c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function with a filter function.  <br /></td></tr>
<tr class="separator:a6f84ecdb9610a4e28f3bd4c5aac59c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef73a684261378924aebeb515cf8119" id="r_a8ef73a684261378924aebeb515cf8119"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ef73a684261378924aebeb515cf8119"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ef73a684261378924aebeb515cf8119">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a8ef73a684261378924aebeb515cf8119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on signed numbers.  <br /></td></tr>
<tr class="separator:a8ef73a684261378924aebeb515cf8119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b720fd242dcaddbe7c710cc29fa4e0" id="r_a94b720fd242dcaddbe7c710cc29fa4e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94b720fd242dcaddbe7c710cc29fa4e0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94b720fd242dcaddbe7c710cc29fa4e0">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a94b720fd242dcaddbe7c710cc29fa4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on unsigned numbers.  <br /></td></tr>
<tr class="separator:a94b720fd242dcaddbe7c710cc29fa4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1178aff6e5bb16b3028695c84bf26ac1" id="r_a1178aff6e5bb16b3028695c84bf26ac1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1178aff6e5bb16b3028695c84bf26ac1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1178aff6e5bb16b3028695c84bf26ac1">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:a1178aff6e5bb16b3028695c84bf26ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise.  <br /></td></tr>
<tr class="separator:a1178aff6e5bb16b3028695c84bf26ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd33fdd83f16bfdc92fd27294b2b45a" id="r_a8dd33fdd83f16bfdc92fd27294b2b45a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dd33fdd83f16bfdc92fd27294b2b45a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8dd33fdd83f16bfdc92fd27294b2b45a">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:a8dd33fdd83f16bfdc92fd27294b2b45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't equal infinity. Returns false otherwise.  <br /></td></tr>
<tr class="separator:a8dd33fdd83f16bfdc92fd27294b2b45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6e51cf80e98374f46d05f6062a8983" id="r_a2e6e51cf80e98374f46d05f6062a8983"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e6e51cf80e98374f46d05f6062a8983">split_program_name</a> (std::string commandline)</td></tr>
<tr class="separator:a2e6e51cf80e98374f46d05f6062a8983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac667eae65a20c5eb67b61d101e656083" id="r_ac667eae65a20c5eb67b61d101e656083"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_integral&lt; T &gt;::value||(sizeof(T)&lt;=1U), <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ac667eae65a20c5eb67b61d101e656083"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classOption.html">Option</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac667eae65a20c5eb67b61d101e656083">default_flag_modifiers</a> (<a class="el" href="classOption.html">Option</a> *opt)</td></tr>
<tr class="memdesc:ac667eae65a20c5eb67b61d101e656083"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper functions for adding in appropriate flag modifiers for add_flag  <br /></td></tr>
<tr class="separator:ac667eae65a20c5eb67b61d101e656083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae379912498be4ea1798e95a5e1a91e" id="r_a2ae379912498be4ea1798e95a5e1a91e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae379912498be4ea1798e95a5e1a91e">maybe_narrow</a> (const char *str)</td></tr>
<tr class="separator:a2ae379912498be4ea1798e95a5e1a91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d07bfa9ac9a2e3eb4a747859a1ca6b" id="r_ad0d07bfa9ac9a2e3eb4a747859a1ca6b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d07bfa9ac9a2e3eb4a747859a1ca6b">maybe_narrow</a> (const wchar_t *str)</td></tr>
<tr class="separator:ad0d07bfa9ac9a2e3eb4a747859a1ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa721c468e5e5701c3b7bffee62f46fa7" id="r_aa721c468e5e5701c3b7bffee62f46fa7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa721c468e5e5701c3b7bffee62f46fa7">convert_arg_for_ini</a> (const std::string &amp;arg, char stringQuote='&quot;', char characterQuote = '\'')</td></tr>
<tr class="separator:aa721c468e5e5701c3b7bffee62f46fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af121fbca2484ea8eb2a20892bed0ce" id="r_a7af121fbca2484ea8eb2a20892bed0ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7af121fbca2484ea8eb2a20892bed0ce">ini_join</a> (const std::vector&lt; std::string &gt; &amp;args, char sepChar=',', char arrayStart='[', char arrayEnd=']', char stringQuote='&quot;', char characterQuote = '\'')</td></tr>
<tr class="memdesc:a7af121fbca2484ea8eb2a20892bed0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comma separated join, adds quotes if needed.  <br /></td></tr>
<tr class="separator:a7af121fbca2484ea8eb2a20892bed0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcf42f08b5337bf646fac80b9123695" id="r_a4dcf42f08b5337bf646fac80b9123695"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dcf42f08b5337bf646fac80b9123695">generate_parents</a> (const std::string &amp;section, std::string &amp;name, char parentSeparator)</td></tr>
<tr class="separator:a4dcf42f08b5337bf646fac80b9123695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322fb234579ecae0046373f55c47ce2c" id="r_a322fb234579ecae0046373f55c47ce2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a322fb234579ecae0046373f55c47ce2c">checkParentSegments</a> (std::vector&lt; <a class="el" href="structConfigItem.html">ConfigItem</a> &gt; &amp;output, const std::string &amp;currentSection, char parentSeparator)</td></tr>
<tr class="memdesc:a322fb234579ecae0046373f55c47ce2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">assuming non default segments do a check on the close and open of the segments in a configItem structure  <br /></td></tr>
<tr class="separator:a322fb234579ecae0046373f55c47ce2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7dcea5f3938db14745073fd1fdbe4d85" id="r_a7dcea5f3938db14745073fd1fdbe4d85"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">enabler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">dummy</a> = {}</td></tr>
<tr class="memdesc:a7dcea5f3938db14745073fd1fdbe4d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance to use in EnableIf.  <br /></td></tr>
<tr class="separator:a7dcea5f3938db14745073fd1fdbe4d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a030bd2eaf73be4d81664d2ca703f7001" name="a030bd2eaf73be4d81664d2ca703f7001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030bd2eaf73be4d81664d2ca703f7001">&#9670;&#160;</a></span>Classifier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a030bd2eaf73be4d81664d2ca703f7001">detail::Classifier</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a030bd2eaf73be4d81664d2ca703f7001ab50339a10e1de285ac99d4c3990b8693" name="a030bd2eaf73be4d81664d2ca703f7001ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a030bd2eaf73be4d81664d2ca703f7001a2b1681c49e27b242d19b93c5c3620cb6" name="a030bd2eaf73be4d81664d2ca703f7001a2b1681c49e27b242d19b93c5c3620cb6"></a>POSITIONAL_MARK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a030bd2eaf73be4d81664d2ca703f7001aa35c2b02966b1563e5bf7b81b8b0cf77" name="a030bd2eaf73be4d81664d2ca703f7001aa35c2b02966b1563e5bf7b81b8b0cf77"></a>SHORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a030bd2eaf73be4d81664d2ca703f7001ac1fabfea54ec6011e694f211f3ffebf3" name="a030bd2eaf73be4d81664d2ca703f7001ac1fabfea54ec6011e694f211f3ffebf3"></a>LONG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a030bd2eaf73be4d81664d2ca703f7001a0693f2b4d4f0740bc76a2d65566b4fda" name="a030bd2eaf73be4d81664d2ca703f7001a0693f2b4d4f0740bc76a2d65566b4fda"></a>WINDOWS_STYLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a030bd2eaf73be4d81664d2ca703f7001ac4fb22412f02354dbe5574e37caf50a7" name="a030bd2eaf73be4d81664d2ca703f7001ac4fb22412f02354dbe5574e37caf50a7"></a>SUBCOMMAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a030bd2eaf73be4d81664d2ca703f7001ab447b0bfeb6e4502fb6a0c4223fb8d00" name="a030bd2eaf73be4d81664d2ca703f7001ab447b0bfeb6e4502fb6a0c4223fb8d00"></a>SUBCOMMAND_TERMINATOR&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l06238">6238</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6238</span>{ <a class="code hl_enumvalue" href="#a030bd2eaf73be4d81664d2ca703f7001ab50339a10e1de285ac99d4c3990b8693">NONE</a>, <a class="code hl_enumvalue" href="#a030bd2eaf73be4d81664d2ca703f7001a2b1681c49e27b242d19b93c5c3620cb6">POSITIONAL_MARK</a>, <a class="code hl_enumvalue" href="#a030bd2eaf73be4d81664d2ca703f7001aa35c2b02966b1563e5bf7b81b8b0cf77">SHORT</a>, <a class="code hl_define" href="http_2model_2clients_8h.html#acaa7b8a7167a8214f499c71c413ddcca">LONG</a>, <a class="code hl_enumvalue" href="#a030bd2eaf73be4d81664d2ca703f7001a0693f2b4d4f0740bc76a2d65566b4fda">WINDOWS_STYLE</a>, <a class="code hl_enumvalue" href="#a030bd2eaf73be4d81664d2ca703f7001ac4fb22412f02354dbe5574e37caf50a7">SUBCOMMAND</a>, <a class="code hl_enumvalue" href="#a030bd2eaf73be4d81664d2ca703f7001ab447b0bfeb6e4502fb6a0c4223fb8d00">SUBCOMMAND_TERMINATOR</a> };</div>
<div class="ttc" id="ahttp_2model_2clients_8h_html_acaa7b8a7167a8214f499c71c413ddcca"><div class="ttname"><a href="http_2model_2clients_8h.html#acaa7b8a7167a8214f499c71c413ddcca">LONG</a></div><div class="ttdeci">#define LONG</div></div>
<div class="ttc" id="anamespacedetail_html_a030bd2eaf73be4d81664d2ca703f7001a0693f2b4d4f0740bc76a2d65566b4fda"><div class="ttname"><a href="#a030bd2eaf73be4d81664d2ca703f7001a0693f2b4d4f0740bc76a2d65566b4fda">detail::Classifier::WINDOWS_STYLE</a></div><div class="ttdeci">@ WINDOWS_STYLE</div></div>
<div class="ttc" id="anamespacedetail_html_a030bd2eaf73be4d81664d2ca703f7001a2b1681c49e27b242d19b93c5c3620cb6"><div class="ttname"><a href="#a030bd2eaf73be4d81664d2ca703f7001a2b1681c49e27b242d19b93c5c3620cb6">detail::Classifier::POSITIONAL_MARK</a></div><div class="ttdeci">@ POSITIONAL_MARK</div></div>
<div class="ttc" id="anamespacedetail_html_a030bd2eaf73be4d81664d2ca703f7001aa35c2b02966b1563e5bf7b81b8b0cf77"><div class="ttname"><a href="#a030bd2eaf73be4d81664d2ca703f7001aa35c2b02966b1563e5bf7b81b8b0cf77">detail::Classifier::SHORT</a></div><div class="ttdeci">@ SHORT</div></div>
<div class="ttc" id="anamespacedetail_html_a030bd2eaf73be4d81664d2ca703f7001ab447b0bfeb6e4502fb6a0c4223fb8d00"><div class="ttname"><a href="#a030bd2eaf73be4d81664d2ca703f7001ab447b0bfeb6e4502fb6a0c4223fb8d00">detail::Classifier::SUBCOMMAND_TERMINATOR</a></div><div class="ttdeci">@ SUBCOMMAND_TERMINATOR</div></div>
<div class="ttc" id="anamespacedetail_html_a030bd2eaf73be4d81664d2ca703f7001ab50339a10e1de285ac99d4c3990b8693"><div class="ttname"><a href="#a030bd2eaf73be4d81664d2ca703f7001ab50339a10e1de285ac99d4c3990b8693">detail::Classifier::NONE</a></div><div class="ttdeci">@ NONE</div></div>
<div class="ttc" id="anamespacedetail_html_a030bd2eaf73be4d81664d2ca703f7001ac4fb22412f02354dbe5574e37caf50a7"><div class="ttname"><a href="#a030bd2eaf73be4d81664d2ca703f7001ac4fb22412f02354dbe5574e37caf50a7">detail::Classifier::SUBCOMMAND</a></div><div class="ttdeci">@ SUBCOMMAND</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad86f32fac98b29b6cae34669baea3710" name="ad86f32fac98b29b6cae34669baea3710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86f32fac98b29b6cae34669baea3710">&#9670;&#160;</a></span>enabler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple empty scoped class. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01374">1374</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1374</span>{};</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5100bdc7b136e623dd6ff2fa45f9560" name="ae5100bdc7b136e623dd6ff2fa45f9560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5100bdc7b136e623dd6ff2fa45f9560">&#9670;&#160;</a></span>path_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560">detail::path_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceCLI.html">CLI</a> enumeration of different file types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae5100bdc7b136e623dd6ff2fa45f9560a357f5c155c9da6842b84ad1066996928" name="ae5100bdc7b136e623dd6ff2fa45f9560a357f5c155c9da6842b84ad1066996928"></a>nonexistent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac" name="ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac"></a>file&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae5100bdc7b136e623dd6ff2fa45f9560a5f8f22b8cdbaeee8cf857673a9b6ba20" name="ae5100bdc7b136e623dd6ff2fa45f9560a5f8f22b8cdbaeee8cf857673a9b6ba20"></a>directory&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03486">3486</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3486</span>{ <a class="code hl_enumvalue" href="#ae5100bdc7b136e623dd6ff2fa45f9560a357f5c155c9da6842b84ad1066996928">nonexistent</a>, <a class="code hl_enumvalue" href="#ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac">file</a>, <a class="code hl_enumvalue" href="#ae5100bdc7b136e623dd6ff2fa45f9560a5f8f22b8cdbaeee8cf857673a9b6ba20">directory</a> };</div>
<div class="ttc" id="anamespacedetail_html_ae5100bdc7b136e623dd6ff2fa45f9560a357f5c155c9da6842b84ad1066996928"><div class="ttname"><a href="#ae5100bdc7b136e623dd6ff2fa45f9560a357f5c155c9da6842b84ad1066996928">detail::path_type::nonexistent</a></div><div class="ttdeci">@ nonexistent</div></div>
<div class="ttc" id="anamespacedetail_html_ae5100bdc7b136e623dd6ff2fa45f9560a5f8f22b8cdbaeee8cf857673a9b6ba20"><div class="ttname"><a href="#ae5100bdc7b136e623dd6ff2fa45f9560a5f8f22b8cdbaeee8cf857673a9b6ba20">detail::path_type::directory</a></div><div class="ttdeci">@ directory</div></div>
<div class="ttc" id="anamespacedetail_html_ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac"><div class="ttname"><a href="#ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac">detail::path_type::file</a></div><div class="ttdeci">@ file</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a28a0f0282738a09f38981410f53200e9" name="a28a0f0282738a09f38981410f53200e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a0f0282738a09f38981410f53200e9">&#9670;&#160;</a></span>check_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560">path_type</a> detail::check_path </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type of the path from a file name </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l04353">4353</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 4353</span>                                                                     {</div>
<div class="line"><span class="lineno"> 4354</span><span class="preprocessor">#if defined(_MSC_VER)</span></div>
<div class="line"><span class="lineno"> 4355</span>            <span class="keyword">struct </span>__stat64 buffer;</div>
<div class="line"><span class="lineno"> 4356</span>            <span class="keywordflow">if</span> (_stat64(file, &amp;buffer) == 0) {</div>
<div class="line"><span class="lineno"> 4357</span>                <span class="keywordflow">return</span> ((buffer.st_mode &amp; S_IFDIR) != 0) ? path_type::directory : path_type::file;</div>
<div class="line"><span class="lineno"> 4358</span>            }</div>
<div class="line"><span class="lineno"> 4359</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 4360</span>            <span class="keyword">struct </span>stat buffer;</div>
<div class="line"><span class="lineno"> 4361</span>            <span class="keywordflow">if</span> (stat(file, &amp;buffer) == 0) {</div>
<div class="line"><span class="lineno"> 4362</span>                <span class="keywordflow">return</span> ((buffer.st_mode &amp; S_IFDIR) != 0) ? path_type::directory : path_type::file;</div>
<div class="line"><span class="lineno"> 4363</span>            }</div>
<div class="line"><span class="lineno"> 4364</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 4365</span>            <span class="keywordflow">return</span> path_type::nonexistent;</div>
<div class="line"><span class="lineno"> 4366</span>        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560a5f8f22b8cdbaeee8cf857673a9b6ba20">directory</a>, <a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560a8c7dd922ad47494fc02c388e12c00eac">file</a>, and <a class="el" href="#ae5100bdc7b136e623dd6ff2fa45f9560a357f5c155c9da6842b84ad1066996928">nonexistent</a>.</p>

</div>
</div>
<a id="a1178aff6e5bb16b3028695c84bf26ac1" name="a1178aff6e5bb16b3028695c84bf26ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1178aff6e5bb16b3028695c84bf26ac1">&#9670;&#160;</a></span>checked_multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; T &gt;::value, bool &gt;::type detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03766">3766</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3766</span>                                                                                            {</div>
<div class="line"><span class="lineno"> 3767</span>            <span class="keywordflow">if</span> (a == 0 || b == 0 || a == 1 || b == 1) {</div>
<div class="line"><span class="lineno"> 3768</span>                a *= b;</div>
<div class="line"><span class="lineno"> 3769</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3770</span>            }</div>
<div class="line"><span class="lineno"> 3771</span>            <span class="keywordflow">if</span> (a == (std::numeric_limits&lt;T&gt;::min)() || b == (std::numeric_limits&lt;T&gt;::min)()) {</div>
<div class="line"><span class="lineno"> 3772</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3773</span>            }</div>
<div class="line"><span class="lineno"> 3774</span>            <span class="keywordflow">if</span> (<a class="code hl_function" href="#a8ef73a684261378924aebeb515cf8119">overflowCheck</a>(a, b)) {</div>
<div class="line"><span class="lineno"> 3775</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3776</span>            }</div>
<div class="line"><span class="lineno"> 3777</span>            a *= b;</div>
<div class="line"><span class="lineno"> 3778</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3779</span>        }</div>
<div class="ttc" id="anamespacedetail_html_a8ef73a684261378924aebeb515cf8119"><div class="ttname"><a href="#a8ef73a684261378924aebeb515cf8119">detail::overflowCheck</a></div><div class="ttdeci">std::enable_if&lt; std::is_signed&lt; T &gt;::value, T &gt;::type overflowCheck(const T &amp;a, const T &amp;b)</div><div class="ttdoc">Do a check for overflow on signed numbers.</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l03752">CLI11.hpp:3752</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8dd33fdd83f16bfdc92fd27294b2b45a" name="a8dd33fdd83f16bfdc92fd27294b2b45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd33fdd83f16bfdc92fd27294b2b45a">&#9670;&#160;</a></span>checked_multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;::type detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't equal infinity. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03783">3783</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3783</span>                                                                                                  {</div>
<div class="line"><span class="lineno"> 3784</span>            T c = a * b;</div>
<div class="line"><span class="lineno"> 3785</span>            <span class="keywordflow">if</span> (std::isinf(c) &amp;&amp; !std::isinf(a) &amp;&amp; !std::isinf(b)) {</div>
<div class="line"><span class="lineno"> 3786</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3787</span>            }</div>
<div class="line"><span class="lineno"> 3788</span>            a = c;</div>
<div class="line"><span class="lineno"> 3789</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3790</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af6841b0d6a5040a03f4ab1948c0641e4" name="af6841b0d6a5040a03f4ab1948c0641e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6841b0d6a5040a03f4ab1948c0641e4">&#9670;&#160;</a></span>checked_to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_same&lt; T1, T2 &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01723">1723</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1723</span>                                         {</div>
<div class="line"><span class="lineno"> 1724</span>            <span class="keywordflow">return</span> std::string{};</div>
<div class="line"><span class="lineno"> 1725</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af93699cc852fd3794098ac36c4ee0881" name="af93699cc852fd3794098ac36c4ee0881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93699cc852fd3794098ac36c4ee0881">&#9670;&#160;</a></span>checked_to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_same&lt; T1, T2 &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="#aacf2ca1139f2ebed02bdfd71de954815">to_string</a>(std::forward&lt;T&gt;(value))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01717">1717</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1717</span>                                                                                       {</div>
<div class="line"><span class="lineno"> 1718</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="#aacf2ca1139f2ebed02bdfd71de954815">to_string</a>(std::forward&lt;T&gt;(value));</div>
<div class="line"><span class="lineno"> 1719</span>        }</div>
<div class="ttc" id="anamespacedetail_html_aacf2ca1139f2ebed02bdfd71de954815"><div class="ttname"><a href="#aacf2ca1139f2ebed02bdfd71de954815">detail::to_string</a></div><div class="ttdeci">auto to_string(T &amp;&amp;value) -&gt; decltype(std::forward&lt; T &gt;(value))</div><div class="ttdoc">Convert an object to a string (directly forward if this can become a string)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01665">CLI11.hpp:1665</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a322fb234579ecae0046373f55c47ce2c" name="a322fb234579ecae0046373f55c47ce2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322fb234579ecae0046373f55c47ce2c">&#9670;&#160;</a></span>checkParentSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::checkParentSegments </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structConfigItem.html">ConfigItem</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>currentSection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>parentSeparator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assuming non default segments do a check on the close and open of the segments in a configItem structure </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l10023">10023</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">10023</span>                                                                                                                                    {</div>
<div class="line"><span class="lineno">10024</span>            std::string estring;</div>
<div class="line"><span class="lineno">10025</span>            <span class="keyword">auto</span> parents = <a class="code hl_function" href="#a4dcf42f08b5337bf646fac80b9123695">detail::generate_parents</a>(currentSection, estring, parentSeparator);</div>
<div class="line"><span class="lineno">10026</span>            <span class="keywordflow">if</span> (!output.empty() &amp;&amp; output.back().name == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><span class="lineno">10027</span>                std::size_t <span class="keyword">const</span> msize = (parents.size() &gt; 1U) ? parents.size() : 2;</div>
<div class="line"><span class="lineno">10028</span>                <span class="keywordflow">while</span> (output.back().parents.size() &gt;= msize) {</div>
<div class="line"><span class="lineno">10029</span>                    output.push_back(output.back());</div>
<div class="line"><span class="lineno">10030</span>                    output.back().parents.pop_back();</div>
<div class="line"><span class="lineno">10031</span>                }</div>
<div class="line"><span class="lineno">10032</span> </div>
<div class="line"><span class="lineno">10033</span>                <span class="keywordflow">if</span> (parents.size() &gt; 1) {</div>
<div class="line"><span class="lineno">10034</span>                    std::size_t common = 0;</div>
<div class="line"><span class="lineno">10035</span>                    std::size_t <span class="keyword">const</span> mpair = (std::min)(output.back().parents.size(), parents.size() - 1);</div>
<div class="line"><span class="lineno">10036</span>                    <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; mpair; ++ii) {</div>
<div class="line"><span class="lineno">10037</span>                        <span class="keywordflow">if</span> (output.back().parents[ii] != parents[ii]) {</div>
<div class="line"><span class="lineno">10038</span>                            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">10039</span>                        }</div>
<div class="line"><span class="lineno">10040</span>                        ++common;</div>
<div class="line"><span class="lineno">10041</span>                    }</div>
<div class="line"><span class="lineno">10042</span>                    <span class="keywordflow">if</span> (common == mpair) {</div>
<div class="line"><span class="lineno">10043</span>                        <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.pop_back();</div>
<div class="line"><span class="lineno">10044</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10045</span>                        <span class="keywordflow">while</span> (<a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().parents.size() &gt; common + 1) {</div>
<div class="line"><span class="lineno">10046</span>                            <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.push_back(<a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back());</div>
<div class="line"><span class="lineno">10047</span>                            <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().parents.pop_back();</div>
<div class="line"><span class="lineno">10048</span>                        }</div>
<div class="line"><span class="lineno">10049</span>                    }</div>
<div class="line"><span class="lineno">10050</span>                    <span class="keywordflow">for</span> (std::size_t ii = common; ii &lt; parents.size() - 1; ++ii) {</div>
<div class="line"><span class="lineno">10051</span>                        <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.emplace_back();</div>
<div class="line"><span class="lineno">10052</span>                        <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().parents.assign(parents.begin(), parents.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(ii) + 1);</div>
<div class="line"><span class="lineno">10053</span>                        <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><span class="lineno">10054</span>                    }</div>
<div class="line"><span class="lineno">10055</span>                }</div>
<div class="line"><span class="lineno">10056</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parents.size() &gt; 1) {</div>
<div class="line"><span class="lineno">10057</span>                <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; parents.size() - 1; ++ii) {</div>
<div class="line"><span class="lineno">10058</span>                    <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.emplace_back();</div>
<div class="line"><span class="lineno">10059</span>                    <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().parents.assign(parents.begin(), parents.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(ii) + 1);</div>
<div class="line"><span class="lineno">10060</span>                    <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><span class="lineno">10061</span>                }</div>
<div class="line"><span class="lineno">10062</span>            }</div>
<div class="line"><span class="lineno">10063</span> </div>
<div class="line"><span class="lineno">10064</span>            <span class="comment">// insert a section end which is just an empty items_buffer</span></div>
<div class="line"><span class="lineno">10065</span>            <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.emplace_back();</div>
<div class="line"><span class="lineno">10066</span>            <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().parents = std::move(parents);</div>
<div class="line"><span class="lineno">10067</span>            <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><span class="lineno">10068</span>        }</div>
<div class="ttc" id="anamespaceCLI_1_1detail_html_a203526b0d52558cb4bfdec88ea1a0d07"><div class="ttname"><a href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">CLI::detail::output</a></div><div class="ttdeci">std::vector&lt; std::string &gt; output</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l00929">CLI11.hpp:929</a></div></div>
<div class="ttc" id="anamespacedetail_html_a4dcf42f08b5337bf646fac80b9123695"><div class="ttname"><a href="#a4dcf42f08b5337bf646fac80b9123695">detail::generate_parents</a></div><div class="ttdeci">std::vector&lt; std::string &gt; generate_parents(const std::string &amp;section, std::string &amp;name, char parentSeparator)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l09999">CLI11.hpp:9999</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa721c468e5e5701c3b7bffee62f46fa7" name="aa721c468e5e5701c3b7bffee62f46fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa721c468e5e5701c3b7bffee62f46fa7">&#9670;&#160;</a></span>convert_arg_for_ini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::convert_arg_for_ini </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>stringQuote</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&quot;'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>characterQuote</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'\''</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l09929">9929</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 9929</span>                                                                                                                {</div>
<div class="line"><span class="lineno"> 9930</span>            <span class="keywordflow">if</span> (arg.empty()) {</div>
<div class="line"><span class="lineno"> 9931</span>                <span class="keywordflow">return</span> std::string(2, stringQuote);</div>
<div class="line"><span class="lineno"> 9932</span>            }</div>
<div class="line"><span class="lineno"> 9933</span>            <span class="comment">// some specifically supported strings</span></div>
<div class="line"><span class="lineno"> 9934</span>            <span class="keywordflow">if</span> (arg == <span class="stringliteral">&quot;true&quot;</span> || arg == <span class="stringliteral">&quot;false&quot;</span> || arg == <span class="stringliteral">&quot;nan&quot;</span> || arg == <span class="stringliteral">&quot;inf&quot;</span>) {</div>
<div class="line"><span class="lineno"> 9935</span>                <span class="keywordflow">return</span> arg;</div>
<div class="line"><span class="lineno"> 9936</span>            }</div>
<div class="line"><span class="lineno"> 9937</span>            <span class="comment">// floating point conversion can convert some hex codes, but don&#39;t try that here</span></div>
<div class="line"><span class="lineno"> 9938</span>            <span class="keywordflow">if</span> (arg.compare(0, 2, <span class="stringliteral">&quot;0x&quot;</span>) != 0 &amp;&amp; arg.compare(0, 2, <span class="stringliteral">&quot;0X&quot;</span>) != 0) {</div>
<div class="line"><span class="lineno"> 9939</span>                <span class="keyword">using </span>CLI::detail::lexical_cast;</div>
<div class="line"><span class="lineno"> 9940</span>                <span class="keywordtype">double</span> val = 0.0;</div>
<div class="line"><span class="lineno"> 9941</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="#a482fea24f39f5d00bae6c530e5e2c5fc">lexical_cast</a>(arg, val)) {</div>
<div class="line"><span class="lineno"> 9942</span>                    <span class="keywordflow">return</span> arg;</div>
<div class="line"><span class="lineno"> 9943</span>                }</div>
<div class="line"><span class="lineno"> 9944</span>            }</div>
<div class="line"><span class="lineno"> 9945</span>            <span class="comment">// just quote a single non numeric character</span></div>
<div class="line"><span class="lineno"> 9946</span>            <span class="keywordflow">if</span> (arg.size() == 1) {</div>
<div class="line"><span class="lineno"> 9947</span>                <span class="keywordflow">return</span> std::string(1, characterQuote) + arg + characterQuote;</div>
<div class="line"><span class="lineno"> 9948</span>            }</div>
<div class="line"><span class="lineno"> 9949</span>            <span class="comment">// handle hex, binary or octal arguments</span></div>
<div class="line"><span class="lineno"> 9950</span>            <span class="keywordflow">if</span> (arg.front() == <span class="charliteral">&#39;0&#39;</span>) {</div>
<div class="line"><span class="lineno"> 9951</span>                <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;x&#39;</span>) {</div>
<div class="line"><span class="lineno"> 9952</span>                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><span class="lineno"> 9953</span>                            return (x &gt;= <span class="stringliteral">&#39;0&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;9&#39;</span>) || (x &gt;= <span class="stringliteral">&#39;A&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;F&#39;</span>) || (x &gt;= <span class="stringliteral">&#39;a&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;f&#39;</span>);</div>
<div class="line"><span class="lineno"> 9954</span>                        })) {</div>
<div class="line"><span class="lineno"> 9955</span>                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><span class="lineno"> 9956</span>                    }</div>
<div class="line"><span class="lineno"> 9957</span>                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;o&#39;</span>) {</div>
<div class="line"><span class="lineno"> 9958</span>                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><span class="lineno"> 9959</span>                            return (x &gt;= <span class="stringliteral">&#39;0&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;7&#39;</span>);</div>
<div class="line"><span class="lineno"> 9960</span>                        })) {</div>
<div class="line"><span class="lineno"> 9961</span>                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><span class="lineno"> 9962</span>                    }</div>
<div class="line"><span class="lineno"> 9963</span>                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;b&#39;</span>) {</div>
<div class="line"><span class="lineno"> 9964</span>                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><span class="lineno"> 9965</span>                            return (x == <span class="stringliteral">&#39;0&#39;</span> || x == <span class="stringliteral">&#39;1&#39;</span>);</div>
<div class="line"><span class="lineno"> 9966</span>                        })) {</div>
<div class="line"><span class="lineno"> 9967</span>                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><span class="lineno"> 9968</span>                    }</div>
<div class="line"><span class="lineno"> 9969</span>                }</div>
<div class="line"><span class="lineno"> 9970</span>            }</div>
<div class="line"><span class="lineno"> 9971</span>            <span class="keywordflow">if</span> (arg.find_first_of(stringQuote) == std::string::npos) {</div>
<div class="line"><span class="lineno"> 9972</span>                <span class="keywordflow">return</span> std::string(1, stringQuote) + arg + stringQuote;</div>
<div class="line"><span class="lineno"> 9973</span>            }</div>
<div class="line"><span class="lineno"> 9974</span>            <span class="keywordflow">return</span> characterQuote + arg + characterQuote;</div>
<div class="line"><span class="lineno"> 9975</span>        }</div>
<div class="ttc" id="anamespacedetail_html_a482fea24f39f5d00bae6c530e5e2c5fc"><div class="ttname"><a href="#a482fea24f39f5d00bae6c530e5e2c5fc">detail::lexical_cast</a></div><div class="ttdeci">bool lexical_cast(const std::string &amp;input, T &amp;output)</div><div class="ttdoc">Integer conversion.</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l02324">CLI11.hpp:2324</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac667eae65a20c5eb67b61d101e656083" name="ac667eae65a20c5eb67b61d101e656083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac667eae65a20c5eb67b61d101e656083">&#9670;&#160;</a></span>default_flag_modifiers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_integral&lt; T &gt;::value||(sizeof(T)&lt;=1U), <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOption.html">Option</a> * detail::default_flag_modifiers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOption.html">Option</a> *</td>          <td class="paramname"><span class="paramname"><em>opt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper functions for adding in appropriate flag modifiers for add_flag </p>
<p>summing modifiers </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l06262">6262</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6262</span>                                                    {</div>
<div class="line"><span class="lineno"> 6263</span>            <span class="keywordflow">return</span> opt-&gt;<a class="code hl_function" href="classOptionBase.html#a409954a54b93250781eb60876af687e2">always_capture_default</a>();</div>
<div class="line"><span class="lineno"> 6264</span>        }</div>
<div class="ttc" id="aclassOptionBase_html_a409954a54b93250781eb60876af687e2"><div class="ttname"><a href="classOptionBase.html#a409954a54b93250781eb60876af687e2">OptionBase::always_capture_default</a></div><div class="ttdeci">CRTP * always_capture_default(bool value=true)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l04806">CLI11.hpp:4806</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad66dfe1973db05decb48edb0db5ac8e9" name="ad66dfe1973db05decb48edb0db5ac8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66dfe1973db05decb48edb0db5ac8e9">&#9670;&#160;</a></span>from_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; <a class="el" href="classdetail_1_1is__istreamable.html">is_istreamable</a>&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool detail::from_stream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>istring</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated operation to get a value from a stream. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01595">1595</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1595</span>                                                           {</div>
<div class="line"><span class="lineno"> 1596</span>            std::istringstream is;</div>
<div class="line"><span class="lineno"> 1597</span>            is.str(istring);</div>
<div class="line"><span class="lineno"> 1598</span>            is &gt;&gt; obj;</div>
<div class="line"><span class="lineno"> 1599</span>            <span class="keywordflow">return</span> !is.fail() &amp;&amp; !is.rdbuf()-&gt;in_avail();</div>
<div class="line"><span class="lineno"> 1600</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a53e52836e0da48333684dc57febdf15d" name="a53e52836e0da48333684dc57febdf15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e52836e0da48333684dc57febdf15d">&#9670;&#160;</a></span>generate_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::generate_map </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>key_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a map. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03677">3677</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3677</span>                                                                    {</div>
<div class="line"><span class="lineno"> 3678</span>            <span class="keyword">using </span>element_t = <span class="keyword">typename</span> <a class="code hl_typedef" href="structdetail_1_1element__type.html#a949f62fe065a8280f9fc695f35920431">detail::element_type&lt;T&gt;::type</a>;</div>
<div class="line"><span class="lineno"> 3679</span>            <span class="keyword">using </span>iteration_type_t = <span class="keyword">typename</span> <a class="code hl_typedef" href="structdetail_1_1pair__adaptor.html#a1e877a36959cad53043899102cdb28a5">detail::pair_adaptor&lt;element_t&gt;::value_type</a>; <span class="comment">// the type of the object pair</span></div>
<div class="line"><span class="lineno"> 3680</span>            std::string out(1, <span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><span class="lineno"> 3681</span>            out.append(detail::join(</div>
<div class="line"><span class="lineno"> 3682</span>                <a class="code hl_function" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(map),</div>
<div class="line"><span class="lineno"> 3683</span>                [key_only](<span class="keyword">const</span> iteration_type_t&amp; v) {</div>
<div class="line"><span class="lineno"> 3684</span>                    std::string res{<a class="code hl_function" href="#aacf2ca1139f2ebed02bdfd71de954815">detail::to_string</a>(<a class="code hl_struct" href="structdetail_1_1pair__adaptor.html">detail::pair_adaptor&lt;element_t&gt;::first</a>(v))};</div>
<div class="line"><span class="lineno"> 3685</span> </div>
<div class="line"><span class="lineno"> 3686</span>                    <span class="keywordflow">if</span> (!key_only) {</div>
<div class="line"><span class="lineno"> 3687</span>                        res.append(<span class="stringliteral">&quot;-&gt;&quot;</span>);</div>
<div class="line"><span class="lineno"> 3688</span>                        res += <a class="code hl_function" href="#aacf2ca1139f2ebed02bdfd71de954815">detail::to_string</a>(<a class="code hl_struct" href="structdetail_1_1pair__adaptor.html">detail::pair_adaptor&lt;element_t&gt;::second</a>(v));</div>
<div class="line"><span class="lineno"> 3689</span>                    }</div>
<div class="line"><span class="lineno"> 3690</span>                    <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno"> 3691</span>                },</div>
<div class="line"><span class="lineno"> 3692</span>                <span class="stringliteral">&quot;,&quot;</span>));</div>
<div class="line"><span class="lineno"> 3693</span>            out.push_back(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"><span class="lineno"> 3694</span>            <span class="keywordflow">return</span> out;</div>
<div class="line"><span class="lineno"> 3695</span>        }</div>
<div class="ttc" id="anamespacedetail_html_a548224c65306dc4738cb1837ef478d95"><div class="ttname"><a href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a></div><div class="ttdeci">auto smart_deref(T value) -&gt; decltype(*value)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l03650">CLI11.hpp:3650</a></div></div>
<div class="ttc" id="astructdetail_1_1element__type_html_a949f62fe065a8280f9fc695f35920431"><div class="ttname"><a href="structdetail_1_1element__type.html#a949f62fe065a8280f9fc695f35920431">detail::element_type::type</a></div><div class="ttdeci">T type</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01450">CLI11.hpp:1450</a></div></div>
<div class="ttc" id="astructdetail_1_1pair__adaptor_html"><div class="ttname"><a href="structdetail_1_1pair__adaptor.html">detail::pair_adaptor</a></div><div class="ttdoc">Adaptor for set-like structure: This just wraps a normal container in a few utilities that do almost ...</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01467">CLI11.hpp:1467</a></div></div>
<div class="ttc" id="astructdetail_1_1pair__adaptor_html_a1e877a36959cad53043899102cdb28a5"><div class="ttname"><a href="structdetail_1_1pair__adaptor.html#a1e877a36959cad53043899102cdb28a5">detail::pair_adaptor::value_type</a></div><div class="ttdeci">typename T::value_type value_type</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01468">CLI11.hpp:1468</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4dcf42f08b5337bf646fac80b9123695" name="a4dcf42f08b5337bf646fac80b9123695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcf42f08b5337bf646fac80b9123695">&#9670;&#160;</a></span>generate_parents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; detail::generate_parents </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>section</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>parentSeparator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l09999">9999</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 9999</span>                                                                                                                            {</div>
<div class="line"><span class="lineno">10000</span>            std::vector&lt;std::string&gt; parents;</div>
<div class="line"><span class="lineno">10001</span>            <span class="keywordflow">if</span> (detail::to_lower(section) != <span class="stringliteral">&quot;default&quot;</span>) {</div>
<div class="line"><span class="lineno">10002</span>                <span class="keywordflow">if</span> (section.find(parentSeparator) != std::string::npos) {</div>
<div class="line"><span class="lineno">10003</span>                    parents = detail::split(section, parentSeparator);</div>
<div class="line"><span class="lineno">10004</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10005</span>                    parents = {section};</div>
<div class="line"><span class="lineno">10006</span>                }</div>
<div class="line"><span class="lineno">10007</span>            }</div>
<div class="line"><span class="lineno">10008</span>            <span class="keywordflow">if</span> (name.find(parentSeparator) != std::string::npos) {</div>
<div class="line"><span class="lineno">10009</span>                std::vector&lt;std::string&gt; plist = detail::split(name, parentSeparator);</div>
<div class="line"><span class="lineno">10010</span>                name = plist.back();</div>
<div class="line"><span class="lineno">10011</span>                detail::remove_quotes(name);</div>
<div class="line"><span class="lineno">10012</span>                plist.pop_back();</div>
<div class="line"><span class="lineno">10013</span>                parents.insert(parents.end(), plist.begin(), plist.end());</div>
<div class="line"><span class="lineno">10014</span>            }</div>
<div class="line"><span class="lineno">10015</span> </div>
<div class="line"><span class="lineno">10016</span>            <span class="comment">// clean up quotes on the parents</span></div>
<div class="line"><span class="lineno">10017</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; parent : parents) {</div>
<div class="line"><span class="lineno">10018</span>                detail::remove_quotes(parent);</div>
<div class="line"><span class="lineno">10019</span>            }</div>
<div class="line"><span class="lineno">10020</span>            <span class="keywordflow">return</span> parents;</div>
<div class="line"><span class="lineno">10021</span>        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceCLI_1_1detail.html#a00aa494e4005562328fae48564194d8f">CLI::detail::remove_quotes()</a>, and <a class="el" href="CLI11_8hpp_source.html#l00702">CLI::detail::to_lower()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_a4dcf42f08b5337bf646fac80b9123695_cgraph.svg" width="391" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa05034c2e5e1b5764f22f1375cd9ade0" name="aa05034c2e5e1b5764f22f1375cd9ade0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05034c2e5e1b5764f22f1375cd9ade0">&#9670;&#160;</a></span>generate_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::generate_set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a set. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03661">3661</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3661</span>                                             {</div>
<div class="line"><span class="lineno"> 3662</span>            <span class="keyword">using </span>element_t = <span class="keyword">typename</span> <a class="code hl_typedef" href="structdetail_1_1element__type.html#a949f62fe065a8280f9fc695f35920431">detail::element_type&lt;T&gt;::type</a>;</div>
<div class="line"><span class="lineno"> 3663</span>            <span class="keyword">using </span>iteration_type_t = <span class="keyword">typename</span> <a class="code hl_typedef" href="structdetail_1_1pair__adaptor.html#a1e877a36959cad53043899102cdb28a5">detail::pair_adaptor&lt;element_t&gt;::value_type</a>; <span class="comment">// the type of the object pair</span></div>
<div class="line"><span class="lineno"> 3664</span>            std::string out(1, <span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><span class="lineno"> 3665</span>            out.append(detail::join(</div>
<div class="line"><span class="lineno"> 3666</span>                <a class="code hl_function" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(set),</div>
<div class="line"><span class="lineno"> 3667</span>                [](<span class="keyword">const</span> iteration_type_t&amp; v) {</div>
<div class="line"><span class="lineno"> 3668</span>                    <span class="keywordflow">return</span> <a class="code hl_function" href="structdetail_1_1pair__adaptor.html#a39847e7621461c7ab519657566920358">detail::pair_adaptor&lt;element_t&gt;::first</a>(v);</div>
<div class="line"><span class="lineno"> 3669</span>                },</div>
<div class="line"><span class="lineno"> 3670</span>                <span class="stringliteral">&quot;,&quot;</span>));</div>
<div class="line"><span class="lineno"> 3671</span>            out.push_back(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"><span class="lineno"> 3672</span>            <span class="keywordflow">return</span> out;</div>
<div class="line"><span class="lineno"> 3673</span>        }</div>
<div class="ttc" id="astructdetail_1_1pair__adaptor_html_a39847e7621461c7ab519657566920358"><div class="ttname"><a href="structdetail_1_1pair__adaptor.html#a39847e7621461c7ab519657566920358">detail::pair_adaptor::first</a></div><div class="ttdeci">static auto first(Q &amp;&amp;pair_value) -&gt; decltype(std::forward&lt; Q &gt;(pair_value))</div><div class="ttdoc">Get the first value (really just the underlying value)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01474">CLI11.hpp:1474</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c468291bac9f60305b1eca08693d306" name="a2c468291bac9f60305b1eca08693d306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c468291bac9f60305b1eca08693d306">&#9670;&#160;</a></span>get_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; detail::get_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract default flag values either {def} or starting with a ! </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03086">3086</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3086</span>                                                                                                            {</div>
<div class="line"><span class="lineno"> 3087</span>            std::vector&lt;std::string&gt; flags = <a class="code hl_function" href="#a89f81a352d3ebced093b357a351bd445">split_names</a>(str);</div>
<div class="line"><span class="lineno"> 3088</span>            flags.erase(std::remove_if(</div>
<div class="line"><span class="lineno"> 3089</span>                            flags.begin(),</div>
<div class="line"><span class="lineno"> 3090</span>                            flags.end(),</div>
<div class="line"><span class="lineno"> 3091</span>                            [](<span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line"><span class="lineno"> 3092</span>                                return ((name.empty()) ||</div>
<div class="line"><span class="lineno"> 3093</span>                                        (!(((name.find_first_of(<span class="stringliteral">&#39;{&#39;</span>) != std::string::npos) &amp;&amp; (name.back() == <span class="stringliteral">&#39;}&#39;</span>)) || (name[0] == <span class="stringliteral">&#39;!&#39;</span>))));</div>
<div class="line"><span class="lineno"> 3094</span>                            }),</div>
<div class="line"><span class="lineno"> 3095</span>                        flags.end());</div>
<div class="line"><span class="lineno"> 3096</span>            std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; output;</div>
<div class="line"><span class="lineno"> 3097</span>            output.reserve(flags.size());</div>
<div class="line"><span class="lineno"> 3098</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; flag : flags) {</div>
<div class="line"><span class="lineno"> 3099</span>                <span class="keyword">auto</span> def_start = flag.find_first_of(<span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><span class="lineno"> 3100</span>                std::string defval = <span class="stringliteral">&quot;false&quot;</span>;</div>
<div class="line"><span class="lineno"> 3101</span>                <span class="keywordflow">if</span> ((def_start != std::string::npos) &amp;&amp; (flag.back() == <span class="charliteral">&#39;}&#39;</span>)) {</div>
<div class="line"><span class="lineno"> 3102</span>                    defval = flag.substr(def_start + 1);</div>
<div class="line"><span class="lineno"> 3103</span>                    defval.pop_back();</div>
<div class="line"><span class="lineno"> 3104</span>                    flag.erase(def_start, std::string::npos); <span class="comment">// NOLINT(readability-suspicious-call-argument)</span></div>
<div class="line"><span class="lineno"> 3105</span>                }</div>
<div class="line"><span class="lineno"> 3106</span>                flag.erase(0, flag.find_first_not_of(<span class="stringliteral">&quot;-!&quot;</span>));</div>
<div class="line"><span class="lineno"> 3107</span>                output.emplace_back(flag, defval);</div>
<div class="line"><span class="lineno"> 3108</span>            }</div>
<div class="line"><span class="lineno"> 3109</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>;</div>
<div class="line"><span class="lineno"> 3110</span>        }</div>
<div class="ttc" id="anamespacedetail_html_a89f81a352d3ebced093b357a351bd445"><div class="ttname"><a href="#a89f81a352d3ebced093b357a351bd445">detail::split_names</a></div><div class="ttdeci">std::vector&lt; std::string &gt; split_names(std::string current)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l03075">CLI11.hpp:3075</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d04a82cd217b4a6e2f16fac14d27778" name="a0d04a82cd217b4a6e2f16fac14d27778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d04a82cd217b4a6e2f16fac14d27778">&#9670;&#160;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, std::string &gt; detail::get_names </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of short names, one of long names, and a single name. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03113">3113</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3113</span>                                                     {</div>
<div class="line"><span class="lineno"> 3114</span>            std::vector&lt;std::string&gt; short_names;</div>
<div class="line"><span class="lineno"> 3115</span>            std::vector&lt;std::string&gt; long_names;</div>
<div class="line"><span class="lineno"> 3116</span>            std::string pos_name;</div>
<div class="line"><span class="lineno"> 3117</span> </div>
<div class="line"><span class="lineno"> 3118</span>            <span class="keywordflow">for</span> (std::string name : input) {</div>
<div class="line"><span class="lineno"> 3119</span>                <span class="keywordflow">if</span> (name.length() == 0) {</div>
<div class="line"><span class="lineno"> 3120</span>                    <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 3121</span>                }</div>
<div class="line"><span class="lineno"> 3122</span>                <span class="keywordflow">if</span> (name.length() &gt; 1 &amp;&amp; name[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; name[1] != <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line"><span class="lineno"> 3123</span>                    <span class="keywordflow">if</span> (name.length() == 2 &amp;&amp; valid_first_char(name[1]))</div>
<div class="line"><span class="lineno"> 3124</span>                        short_names.emplace_back(1, name[1]);</div>
<div class="line"><span class="lineno"> 3125</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 3126</span>                        <span class="keywordflow">throw</span> <a class="code hl_function" href="classBadNameString.html#a674872f33d808dff17987ddf2e871d2d">BadNameString::OneCharName</a>(name);</div>
<div class="line"><span class="lineno"> 3127</span>                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name.length() &gt; 2 &amp;&amp; name.substr(0, 2) == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><span class="lineno"> 3128</span>                    name = name.substr(2);</div>
<div class="line"><span class="lineno"> 3129</span>                    <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceCLI_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">valid_name_string</a>(name))</div>
<div class="line"><span class="lineno"> 3130</span>                        long_names.push_back(name);</div>
<div class="line"><span class="lineno"> 3131</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 3132</span>                        <span class="keywordflow">throw</span> <a class="code hl_function" href="classBadNameString.html#a1d0b6f097d3fbf4ca16c04ff89657593">BadNameString::BadLongName</a>(name);</div>
<div class="line"><span class="lineno"> 3133</span>                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;-&quot;</span> || name == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><span class="lineno"> 3134</span>                    <span class="keywordflow">throw</span> <a class="code hl_function" href="classBadNameString.html#a6e4677e57b77ac691763e41871f54789">BadNameString::DashesOnly</a>(name);</div>
<div class="line"><span class="lineno"> 3135</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3136</span>                    <span class="keywordflow">if</span> (pos_name.length() &gt; 0)</div>
<div class="line"><span class="lineno"> 3137</span>                        <span class="keywordflow">throw</span> <a class="code hl_function" href="classBadNameString.html#a7ed0e0c21d8a639e523f7c4a89511f66">BadNameString::MultiPositionalNames</a>(name);</div>
<div class="line"><span class="lineno"> 3138</span>                    pos_name = name;</div>
<div class="line"><span class="lineno"> 3139</span>                }</div>
<div class="line"><span class="lineno"> 3140</span>            }</div>
<div class="line"><span class="lineno"> 3141</span> </div>
<div class="line"><span class="lineno"> 3142</span>            <span class="keywordflow">return</span> std::make_tuple(short_names, long_names, pos_name);</div>
<div class="line"><span class="lineno"> 3143</span>        }</div>
<div class="ttc" id="aclassBadNameString_html_a1d0b6f097d3fbf4ca16c04ff89657593"><div class="ttname"><a href="classBadNameString.html#a1d0b6f097d3fbf4ca16c04ff89657593">BadNameString::BadLongName</a></div><div class="ttdeci">static BadNameString BadLongName(std::string name)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01119">CLI11.hpp:1119</a></div></div>
<div class="ttc" id="aclassBadNameString_html_a674872f33d808dff17987ddf2e871d2d"><div class="ttname"><a href="classBadNameString.html#a674872f33d808dff17987ddf2e871d2d">BadNameString::OneCharName</a></div><div class="ttdeci">static BadNameString OneCharName(std::string name)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01116">CLI11.hpp:1116</a></div></div>
<div class="ttc" id="aclassBadNameString_html_a6e4677e57b77ac691763e41871f54789"><div class="ttname"><a href="classBadNameString.html#a6e4677e57b77ac691763e41871f54789">BadNameString::DashesOnly</a></div><div class="ttdeci">static BadNameString DashesOnly(std::string name)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01122">CLI11.hpp:1122</a></div></div>
<div class="ttc" id="aclassBadNameString_html_a7ed0e0c21d8a639e523f7c4a89511f66"><div class="ttname"><a href="classBadNameString.html#a7ed0e0c21d8a639e523f7c4a89511f66">BadNameString::MultiPositionalNames</a></div><div class="ttdeci">static BadNameString MultiPositionalNames(std::string name)</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l01125">CLI11.hpp:1125</a></div></div>
<div class="ttc" id="anamespaceCLI_1_1detail_html_a4274628d24f9e3fbc719284f1db263b8"><div class="ttname"><a href="namespaceCLI_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">CLI::detail::valid_name_string</a></div><div class="ttdeci">bool valid_name_string(const std::string &amp;str)</div><div class="ttdoc">Verify an option/subcommand name.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7af121fbca2484ea8eb2a20892bed0ce" name="a7af121fbca2484ea8eb2a20892bed0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af121fbca2484ea8eb2a20892bed0ce">&#9670;&#160;</a></span>ini_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::ini_join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>sepChar</em></span><span class="paramdefsep"> = </span><span class="paramdefval">','</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>arrayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'['</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>arrayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">']'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>stringQuote</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&quot;'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>characterQuote</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'\''</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comma separated join, adds quotes if needed. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l09977">9977</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 9978</span>                                                                                                                                   {</div>
<div class="line"><span class="lineno"> 9979</span>            std::string joined;</div>
<div class="line"><span class="lineno"> 9980</span>            <span class="keywordflow">if</span> (args.size() &gt; 1 &amp;&amp; arrayStart != <span class="charliteral">&#39;\0&#39;</span>) {</div>
<div class="line"><span class="lineno"> 9981</span>                joined.push_back(arrayStart);</div>
<div class="line"><span class="lineno"> 9982</span>            }</div>
<div class="line"><span class="lineno"> 9983</span>            std::size_t start = 0;</div>
<div class="line"><span class="lineno"> 9984</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : args) {</div>
<div class="line"><span class="lineno"> 9985</span>                <span class="keywordflow">if</span> (start++ &gt; 0) {</div>
<div class="line"><span class="lineno"> 9986</span>                    joined.push_back(sepChar);</div>
<div class="line"><span class="lineno"> 9987</span>                    <span class="keywordflow">if</span> (!std::isspace&lt;char&gt;(sepChar, std::locale())) {</div>
<div class="line"><span class="lineno"> 9988</span>                        joined.push_back(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"><span class="lineno"> 9989</span>                    }</div>
<div class="line"><span class="lineno"> 9990</span>                }</div>
<div class="line"><span class="lineno"> 9991</span>                joined.append(<a class="code hl_function" href="#aa721c468e5e5701c3b7bffee62f46fa7">convert_arg_for_ini</a>(arg, stringQuote, characterQuote));</div>
<div class="line"><span class="lineno"> 9992</span>            }</div>
<div class="line"><span class="lineno"> 9993</span>            <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceCLI_1_1detail.html#a4042691796ce0e06edeb3e35de7c26d3">args</a>.size() &gt; 1 &amp;&amp; arrayEnd != <span class="charliteral">&#39;\0&#39;</span>) {</div>
<div class="line"><span class="lineno"> 9994</span>                joined.push_back(arrayEnd);</div>
<div class="line"><span class="lineno"> 9995</span>            }</div>
<div class="line"><span class="lineno"> 9996</span>            <span class="keywordflow">return</span> joined;</div>
<div class="line"><span class="lineno"> 9997</span>        }</div>
<div class="ttc" id="anamespaceCLI_1_1detail_html_a4042691796ce0e06edeb3e35de7c26d3"><div class="ttname"><a href="namespaceCLI_1_1detail.html#a4042691796ce0e06edeb3e35de7c26d3">CLI::detail::args</a></div><div class="ttdeci">const std::vector&lt; const char * &gt; &amp; args()</div><div class="ttdoc">Command-line arguments, as passed in to this executable, converted to utf-8 on Windows.</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l00444">CLI11.hpp:444</a></div></div>
<div class="ttc" id="anamespacedetail_html_aa721c468e5e5701c3b7bffee62f46fa7"><div class="ttname"><a href="#aa721c468e5e5701c3b7bffee62f46fa7">detail::convert_arg_for_ini</a></div><div class="ttdeci">std::string convert_arg_for_ini(const std::string &amp;arg, char stringQuote='&quot;', char characterQuote = '\'')</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l09929">CLI11.hpp:9929</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae2ef87849dccacec9ed8fef6604ba2cd" name="ae2ef87849dccacec9ed8fef6604ba2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ef87849dccacec9ed8fef6604ba2cd">&#9670;&#160;</a></span>integral_conversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; I&lt; <a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type <a class="el" href="#a9bec111d9f18677e64ece6787a824f21">tuple_type_size</a>() { return <a class="el" href="structdetail_1_1subtype__count.html">subtype_count</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+<a class="el" href="#a9bec111d9f18677e64ece6787a824f21">tuple_type_size</a>&lt; T, I+1 &gt;(); } template&lt; typename T &gt; struct <a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="#a9bec111d9f18677e64ece6787a824f21">tuple_type_size</a>&lt; T, 0 &gt;()}; }; template&lt; typename T &gt; struct <a class="el" href="structdetail_1_1subtype__count.html">subtype_count</a> { static constexpr int value{<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ? expected_max_vector_size :<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value}; }; template&lt; typename T, typename Enable=void &gt; struct type_count_min { static const int value{0}; }; template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp; !<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value}; }; template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1}; }; template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="structdetail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename T::value_type &gt;::value}; }; template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I==<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return 0; } template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; <a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return <a class="el" href="structdetail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;(); } template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size_min&lt; T, 0 &gt;()}; }; template&lt; typename T &gt; struct <a class="el" href="structdetail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr int value{<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ?((<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value&lt; expected_max_vector_size) ? <a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value}; }; template&lt; typename T, typename Enable=void &gt; struct expected_count { static const int value{0}; }; template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1}; }; template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt; <a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_max_vector_size}; }; template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_count&lt; typename T::value_type &gt;::value}; }; enum class object_category :int { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, wstring_assignable=25, wstring_constructible=26, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80, }; template&lt; typename T, typename Enable=void &gt; struct classify_object { static constexpr object_category value{object_category::other}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp; std::is_signed&lt; T &gt;::value &amp;&amp;!<a class="el" href="structis__bool.html">is_bool</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integral_value}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp; !std::is_same&lt; T, char &gt;::value &amp;&amp;!<a class="el" href="structis__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::unsigned_integral}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, char &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::char_value}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="structis__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::boolean_value}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::floating_point}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp; std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_assignable}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp; !std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1) &amp;&amp; std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_constructible}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp; !std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp; std::is_assignable&lt; T &amp;, std::wstring &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::wstring_assignable}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp; !std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp; !std::is_assignable&lt; T &amp;, std::wstring &gt;::value &amp;&amp;(<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1) &amp;&amp; std::is_constructible&lt; T, std::wstring &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::wstring_constructible}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::enumeration}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::complex_number}; }; template&lt; typename T &gt; struct uncommon_type { using type=typename std::conditional&lt; !std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp; !std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::wstring &gt;::value &amp;&amp; !std::is_constructible&lt; T, std::wstring &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp; !std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type; static constexpr bool value=type::value; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;(!<a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp; !<a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value{object_category::wrapper_value}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp; <a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::number_constructible}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp; !<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integer_constructible}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp; <a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::double_constructible}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="classdetail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;((<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value &gt;=2 &amp;&amp;!<a class="el" href="structdetail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp; !<a class="el" href="classdetail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1type__count.html">type_count</a>&lt; T &gt;::value &gt;=2))&gt;::type &gt; { static constexpr object_category value{object_category::tuple_value}; }; template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="structdetail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::container_value}; }; template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::char_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;CHAR&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::integral_value|| classify_object&lt; T &gt;::value==object_category::integer_constructible, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;INT&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;UINT&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::floating_point|| classify_object&lt; T &gt;::value==object_category::number_constructible|| classify_object&lt; T &gt;::value==object_category::double_constructible, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;FLOAT&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::enumeration, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;ENUM&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;BOOLEAN&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::complex_number, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;COMPLEX&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp; classify_object&lt; T &gt;::value&lt;=object_category::other, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;TEXT&quot;; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; std::string type_name(); template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::container_value|| classify_object&lt; T &gt;::value==object_category::wrapper_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; std::string type_name(); template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value==1, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;(); } template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt; I==<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string{}; } template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt;(I&lt; <a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value), std::string &gt;::type tuple_name() { auto str= std::string{type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;()}+','+tuple_name&lt; T, I+1 &gt;(); if(str.back()==',') str.pop_back(); return str; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt; &gt; inline std::string type_name() { auto tname=std::string(1, '[')+tuple_name&lt; T, 0 &gt;(); tname.push_back(']'); return tname; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::container_value|| classify_object&lt; T &gt;::value==object_category::wrapper_value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt; &gt; inline std::string type_name() { return type_name&lt; typename T::value_type &gt;(); } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; bool integral_conversion(const std::string &amp;input, T &amp;output) noexcept { if(input.empty()||input.front()=='-') { return false; } char *val=nullptr; errno=0; std::uint64_t const output_ll=std::strtoull(input.c_str(), &amp;val, 0); if(errno==ERANGE) { return false; } output=static_cast&lt; T &gt;(output_ll); if(val==(input.c_str()+input.size()) &amp;&amp;static_cast&lt; std::uint64_t &gt;(output)==output_ll) { return true; } val=nullptr; std::int64_t const output_sll=std::strtoll(input.c_str(), &amp;val, 0); if(val==(input.c_str()+input.size())) { output=(output_sll&lt; 0) ? static_cast&lt; T &gt;(0) :static_cast&lt; T &gt;(output_sll); return(static_cast&lt; std::int64_t &gt;(output)==output_sll); } return false; } template&lt; typename T, <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_signed&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;=<a class="el" href="#a7dcea5f3938db14745073fd1fdbe4d85">detail::dummy</a> &gt; bool detail::integral_conversion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively generate the tuple type name. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l02254">2254</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2254</span>                                                                             {</div>
<div class="line"><span class="lineno"> 2255</span>            <span class="keywordflow">if</span> (input.empty()) {</div>
<div class="line"><span class="lineno"> 2256</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2257</span>            }</div>
<div class="line"><span class="lineno"> 2258</span>            <span class="keywordtype">char</span>* val = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2259</span>            errno = 0;</div>
<div class="line"><span class="lineno"> 2260</span>            std::int64_t <span class="keyword">const</span> output_ll = std::strtoll(input.c_str(), &amp;val, 0);</div>
<div class="line"><span class="lineno"> 2261</span>            <span class="keywordflow">if</span> (errno == ERANGE) {</div>
<div class="line"><span class="lineno"> 2262</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2263</span>            }</div>
<div class="line"><span class="lineno"> 2264</span>            <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a> = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(output_ll);</div>
<div class="line"><span class="lineno"> 2265</span>            <span class="keywordflow">if</span> (val == (input.c_str() + input.size()) &amp;&amp; <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(<a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a>) == output_ll) {</div>
<div class="line"><span class="lineno"> 2266</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2267</span>            }</div>
<div class="line"><span class="lineno"> 2268</span>            <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;true&quot;</span>) {</div>
<div class="line"><span class="lineno"> 2269</span>                <span class="comment">// this is to deal with a few oddities with flags and wrapper int types</span></div>
<div class="line"><span class="lineno"> 2270</span>                <a class="code hl_variable" href="namespaceCLI_1_1detail.html#a203526b0d52558cb4bfdec88ea1a0d07">output</a> = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(1);</div>
<div class="line"><span class="lineno"> 2271</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2272</span>            }</div>
<div class="line"><span class="lineno"> 2273</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2274</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a53cdfb59576b0d3059bca113b6817da9" name="a53cdfb59576b0d3059bca113b6817da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cdfb59576b0d3059bca113b6817da9">&#9670;&#160;</a></span>lexical_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AssignTo , typename ConvertTo , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible||classify_object&lt; AssignTo &gt;::value==object_category::wstring_assignable||classify_object&lt; AssignTo &gt;::value==object_category::wstring_constructible), <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool detail::lexical_assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignTo &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a value through lexical cast operations. </p>
<p>Assign a value from a lexical cast through constructing a value and move assigning it.</p>
<p>Assign a value converted from a string in lexical cast to the output value directly.</p>
<p>Assign a value through lexical cast operations Strings can be empty so we need to do a little different</p>
<p>Assign a value through lexical cast operations for int compatible values mainly for atomic operations on some compilers </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l02556">2556</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2556</span>                                                                      {</div>
<div class="line"><span class="lineno"> 2557</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="#a482fea24f39f5d00bae6c530e5e2c5fc">lexical_cast</a>(input, output);</div>
<div class="line"><span class="lineno"> 2558</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a482fea24f39f5d00bae6c530e5e2c5fc" name="a482fea24f39f5d00bae6c530e5e2c5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482fea24f39f5d00bae6c530e5e2c5fc">&#9670;&#160;</a></span>lexical_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool detail::lexical_cast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer conversion. </p>
<p>Non-string parsable by a stream.</p>
<p>Non-string convertible from an int.</p>
<p>Assignable from double.</p>
<p>Assignable from int.</p>
<p>Assignable from double or int.</p>
<p>wrapper types</p>
<p>Enumerations.</p>
<p>Wide strings.</p>
<p>String and similar constructible and copy assignment.</p>
<p>String and similar direct assignment.</p>
<p>complex</p>
<p>Floats.</p>
<p>Boolean values.</p>
<p>char values </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l02324">2324</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2324</span>                                                             {</div>
<div class="line"><span class="lineno"> 2325</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="#ae2ef87849dccacec9ed8fef6604ba2cd">integral_conversion</a>(input, output);</div>
<div class="line"><span class="lineno"> 2326</span>        }</div>
<div class="ttc" id="anamespacedetail_html_ae2ef87849dccacec9ed8fef6604ba2cd"><div class="ttname"><a href="#ae2ef87849dccacec9ed8fef6604ba2cd">detail::integral_conversion</a></div><div class="ttdeci">constexpr std::enable_if&lt; I&lt; type_count_base&lt; T &gt;::value, int &gt;::type tuple_type_size() { return subtype_count&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size&lt; T, I+1 &gt;();} template&lt; typename T &gt; struct type_count&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size&lt; T, 0 &gt;()};};template&lt; typename T &gt; struct subtype_count { static constexpr int value{is_mutable_container&lt; T &gt;::value ? expected_max_vector_size :type_count&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct type_count_min { static const int value{0};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{type_count&lt; T &gt;::value};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{subtype_count_min&lt; typename T::value_type &gt;::value};};template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I==type_count_base&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return 0;} template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; type_count_base&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return subtype_count_min&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;();} template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size_min&lt; T, 0 &gt;()};};template&lt; typename T &gt; struct subtype_count_min { static constexpr int value{is_mutable_container&lt; T &gt;::value ?((type_count&lt; T &gt;::value&lt; expected_max_vector_size) ? type_count&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct expected_count { static const int value{0};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_max_vector_size};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;is_wrapper&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_count&lt; typename T::value_type &gt;::value};};enum class object_category :int { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, wstring_assignable=25, wstring_constructible=26, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80, };template&lt; typename T, typename Enable=void &gt; struct classify_object { static constexpr object_category value{object_category::other};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;!is_bool&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integral_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;!is_bool&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::unsigned_integral};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, char &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::char_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; is_bool&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::boolean_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::floating_point};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_assignable};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(type_count&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::wstring &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::wstring_assignable};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::wstring &gt;::value &amp;&amp;(type_count&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::wstring &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::wstring_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::enumeration};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::complex_number};};template&lt; typename T &gt; struct uncommon_type { using type=typename std::conditional&lt; !std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::wstring &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::wstring &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type;static constexpr bool value=type::value;};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;(!is_mutable_container&lt; T &gt;::value &amp;&amp;is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value{object_category::wrapper_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;type_count&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;is_direct_constructible&lt; T, double &gt;::value &amp;&amp;is_direct_constructible&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::number_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;type_count&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_direct_constructible&lt; T, double &gt;::value &amp;&amp;is_direct_constructible&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integer_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;type_count&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;is_direct_constructible&lt; T, double &gt;::value &amp;&amp;!is_direct_constructible&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::double_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;((type_count&lt; T &gt;::value &gt;=2 &amp;&amp;!is_wrapper&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!is_direct_constructible&lt; T, double &gt;::value &amp;&amp;!is_direct_constructible&lt; T, int &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;type_count&lt; T &gt;::value &gt;=2))&gt;::type &gt; { static constexpr object_category value{object_category::tuple_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::container_value};};template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::char_value, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;CHAR&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::integer_constructible, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;INT&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;UINT&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::floating_point||classify_object&lt; T &gt;::value==object_category::number_constructible||classify_object&lt; T &gt;::value==object_category::double_constructible, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;FLOAT&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::enumeration, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;ENUM&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;BOOLEAN&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::complex_number, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;COMPLEX&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp;classify_object&lt; T &gt;::value&lt;=object_category::other, detail::enabler &gt;=detail::dummy &gt; constexpr const char *type_name() { return &quot;TEXT&quot;;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;type_count_base&lt; T &gt;::value &gt;=2, detail::enabler &gt;=detail::dummy &gt; std::string type_name();template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt;=detail::dummy &gt; std::string type_name();template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;type_count_base&lt; T &gt;::value==1, detail::enabler &gt;=detail::dummy &gt; inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;();} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt; I==type_count_base&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string{};} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt;(I&lt; type_count_base&lt; T &gt;::value), std::string &gt;::type tuple_name() { auto str=std::string{type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;()}+','+tuple_name&lt; T, I+1 &gt;();if(str.back()==',') str.pop_back();return str;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;type_count_base&lt; T &gt;::value &gt;=2, detail::enabler &gt; &gt; inline std::string type_name() { auto tname=std::string(1, '[')+tuple_name&lt; T, 0 &gt;();tname.push_back(']');return tname;} template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; inline std::string type_name() { return type_name&lt; typename T::value_type &gt;();} template&lt; typename T, enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;=detail::dummy &gt; bool integral_conversion(const std::string &amp;input, T &amp;output) noexcept { if(input.empty()||input.front()=='-') { return false;} char *val=nullptr;errno=0;std::uint64_t const output_ll=std::strtoull(input.c_str(), &amp;val, 0);if(errno==ERANGE) { return false;} output=static_cast&lt; T &gt;(output_ll);if(val==(input.c_str()+input.size()) &amp;&amp;static_cast&lt; std::uint64_t &gt;(output)==output_ll) { return true;} val=nullptr;std::int64_t const output_sll=std::strtoll(input.c_str(), &amp;val, 0);if(val==(input.c_str()+input.size())) { output=(output_sll&lt; 0) ? static_cast&lt; T &gt;(0) :static_cast&lt; T &gt;(output_sll);return(static_cast&lt; std::int64_t &gt;(output)==output_sll);} return false;} template&lt; typename T, enable_if_t&lt; std::is_signed&lt; T &gt;::value, detail::enabler &gt;=detail::dummy &gt; bool integral_conversion(const std::string &amp;input, T &amp;output) noexcept</div><div class="ttdoc">Recursively generate the tuple type name.</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l02254">CLI11.hpp:2254</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ae379912498be4ea1798e95a5e1a91e" name="a2ae379912498be4ea1798e95a5e1a91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae379912498be4ea1798e95a5e1a91e">&#9670;&#160;</a></span>maybe_narrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * detail::maybe_narrow </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l08184">8184</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 8184</span>                                                               {</div>
<div class="line"><span class="lineno"> 8185</span>            <span class="keywordflow">return</span> str;</div>
<div class="line"><span class="lineno"> 8186</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0d07bfa9ac9a2e3eb4a747859a1ca6b" name="ad0d07bfa9ac9a2e3eb4a747859a1ca6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d07bfa9ac9a2e3eb4a747859a1ca6b">&#9670;&#160;</a></span>maybe_narrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::maybe_narrow </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l08187">8187</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 8187</span>                                                                {</div>
<div class="line"><span class="lineno"> 8188</span>            <span class="keywordflow">return</span> narrow(str);</div>
<div class="line"><span class="lineno"> 8189</span>        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CLI11_8hpp_source.html#l00372">CLI::narrow()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_ad0d07bfa9ac9a2e3eb4a747859a1ca6b_cgraph.svg" width="318" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8ef73a684261378924aebeb515cf8119" name="a8ef73a684261378924aebeb515cf8119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef73a684261378924aebeb515cf8119">&#9670;&#160;</a></span>overflowCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_signed&lt; T &gt;::value, T &gt;::type detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on signed numbers. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03752">3752</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3752</span>                                                                                                        {</div>
<div class="line"><span class="lineno"> 3753</span>            <span class="keywordflow">if</span> ((a &gt; 0) == (b &gt; 0)) {</div>
<div class="line"><span class="lineno"> 3754</span>                <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::max)() / (std::abs)(a) &lt; (std::abs)(b));</div>
<div class="line"><span class="lineno"> 3755</span>            }</div>
<div class="line"><span class="lineno"> 3756</span>            <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::min)() / (std::abs)(a) &gt; -(std::abs)(b));</div>
<div class="line"><span class="lineno"> 3757</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94b720fd242dcaddbe7c710cc29fa4e0" name="a94b720fd242dcaddbe7c710cc29fa4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b720fd242dcaddbe7c710cc29fa4e0">&#9670;&#160;</a></span>overflowCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on unsigned numbers. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03760">3760</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3760</span>                                                                                                         {</div>
<div class="line"><span class="lineno"> 3761</span>            <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::max)() / a &lt; b);</div>
<div class="line"><span class="lineno"> 3762</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0c0ee20a405b0ba24764e1e35120519" name="ad0c0ee20a405b0ba24764e1e35120519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c0ee20a405b0ba24764e1e35120519">&#9670;&#160;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!<a class="el" href="structdetail_1_1has__find.html">has_find</a>&lt; T, V &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;) -&gt; std::pair&lt;bool, decltype(std::begin(<a class="el" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(set)))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function. </p>
<p>A search function that uses the built in find function. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03710">3710</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3710</span>                                                                                                             {</div>
<div class="line"><span class="lineno"> 3711</span>            <span class="keyword">using </span>element_t = <span class="keyword">typename</span> <a class="code hl_typedef" href="structdetail_1_1element__type.html#a949f62fe065a8280f9fc695f35920431">detail::element_type&lt;T&gt;::type</a>;</div>
<div class="line"><span class="lineno"> 3712</span>            <span class="keyword">auto</span>&amp; setref = <a class="code hl_function" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(set);</div>
<div class="line"><span class="lineno"> 3713</span>            <span class="keyword">auto</span> it = std::find_if(std::begin(setref), std::end(setref), [&amp;val](<span class="keyword">decltype</span>(*std::begin(setref)) v) {</div>
<div class="line"><span class="lineno"> 3714</span>                <span class="keywordflow">return</span> (<a class="code hl_struct" href="structdetail_1_1pair__adaptor.html">detail::pair_adaptor&lt;element_t&gt;::first</a>(v) == val);</div>
<div class="line"><span class="lineno"> 3715</span>            });</div>
<div class="line"><span class="lineno"> 3716</span>            <span class="keywordflow">return</span> {(it != std::end(setref)), it};</div>
<div class="line"><span class="lineno"> 3717</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f84ecdb9610a4e28f3bd4c5aac59c46" name="a6f84ecdb9610a4e28f3bd4c5aac59c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f84ecdb9610a4e28f3bd4c5aac59c46">&#9670;&#160;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; V(V)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>filter_function</em></span>&#160;) -&gt; std::pair&lt;bool, decltype(std::begin(<a class="el" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(set)))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function with a filter function. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03729">3729</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3730</span>                                                                         {</div>
<div class="line"><span class="lineno"> 3731</span>            <span class="keyword">using </span>element_t = <span class="keyword">typename</span> <a class="code hl_typedef" href="structdetail_1_1element__type.html#a949f62fe065a8280f9fc695f35920431">detail::element_type&lt;T&gt;::type</a>;</div>
<div class="line"><span class="lineno"> 3732</span>            <span class="comment">// do the potentially faster first search</span></div>
<div class="line"><span class="lineno"> 3733</span>            <span class="keyword">auto</span> res = <a class="code hl_function" href="#ad0c0ee20a405b0ba24764e1e35120519">search</a>(set, val);</div>
<div class="line"><span class="lineno"> 3734</span>            <span class="keywordflow">if</span> ((res.first) || (!(filter_function))) {</div>
<div class="line"><span class="lineno"> 3735</span>                <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno"> 3736</span>            }</div>
<div class="line"><span class="lineno"> 3737</span>            <span class="comment">// if we haven&#39;t found it do the longer linear search with all the element translations</span></div>
<div class="line"><span class="lineno"> 3738</span>            <span class="keyword">auto</span>&amp; setref = <a class="code hl_function" href="#a548224c65306dc4738cb1837ef478d95">detail::smart_deref</a>(set);</div>
<div class="line"><span class="lineno"> 3739</span>            <span class="keyword">auto</span> it = std::find_if(std::begin(setref), std::end(setref), [&amp;](<span class="keyword">decltype</span>(*std::begin(setref)) v) {</div>
<div class="line"><span class="lineno"> 3740</span>                V a{<a class="code hl_function" href="structdetail_1_1pair__adaptor.html#a39847e7621461c7ab519657566920358">detail::pair_adaptor&lt;element_t&gt;::first</a>(v)};</div>
<div class="line"><span class="lineno"> 3741</span>                a = filter_function(a);</div>
<div class="line"><span class="lineno"> 3742</span>                <span class="keywordflow">return</span> (a == val);</div>
<div class="line"><span class="lineno"> 3743</span>            });</div>
<div class="line"><span class="lineno"> 3744</span>            <span class="keywordflow">return</span> {(it != std::end(setref)), it};</div>
<div class="line"><span class="lineno"> 3745</span>        }</div>
<div class="ttc" id="anamespacedetail_html_ad0c0ee20a405b0ba24764e1e35120519"><div class="ttname"><a href="#ad0c0ee20a405b0ba24764e1e35120519">detail::search</a></div><div class="ttdeci">auto search(const T &amp;set, const V &amp;val) -&gt; std::pair&lt; bool, decltype(std::begin(detail::smart_deref(set)))&gt;</div><div class="ttdoc">A search function.</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l03710">CLI11.hpp:3710</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a384df3a85d5f165632c952a37d53ea15" name="a384df3a85d5f165632c952a37d53ea15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384df3a85d5f165632c952a37d53ea15">&#9670;&#160;</a></span>smart_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!<a class="el" href="structis__copyable__ptr.html">is_copyable_ptr</a>&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt; T &gt;::type &amp; detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03656">3656</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3656</span>                                                                   {</div>
<div class="line"><span class="lineno"> 3657</span>            <span class="keywordflow">return</span> value;</div>
<div class="line"><span class="lineno"> 3658</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a548224c65306dc4738cb1837ef478d95" name="a548224c65306dc4738cb1837ef478d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548224c65306dc4738cb1837ef478d95">&#9670;&#160;</a></span>smart_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; <a class="el" href="structis__copyable__ptr.html">is_copyable_ptr</a>&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; decltype(*value) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03650">3650</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3650</span>                                                      {</div>
<div class="line"><span class="lineno"> 3651</span>            <span class="keywordflow">return</span> *value;</div>
<div class="line"><span class="lineno"> 3652</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a763e23060ad5d66064604003ccb689f6" name="a763e23060ad5d66064604003ccb689f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763e23060ad5d66064604003ccb689f6">&#9670;&#160;</a></span>split_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool detail::split_long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03045">3045</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3045</span>                                                                                                  {</div>
<div class="line"><span class="lineno"> 3046</span>            <span class="keywordflow">if</span> (current.size() &gt; 2 &amp;&amp; current.compare(0, 2, <span class="stringliteral">&quot;--&quot;</span>) == 0 &amp;&amp; valid_first_char(current[2])) {</div>
<div class="line"><span class="lineno"> 3047</span>                <span class="keyword">auto</span> loc = current.find_first_of(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line"><span class="lineno"> 3048</span>                <span class="keywordflow">if</span> (loc != std::string::npos) {</div>
<div class="line"><span class="lineno"> 3049</span>                    name = current.substr(2, loc - 2);</div>
<div class="line"><span class="lineno"> 3050</span>                    value = current.substr(loc + 1);</div>
<div class="line"><span class="lineno"> 3051</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3052</span>                    name = current.substr(2);</div>
<div class="line"><span class="lineno"> 3053</span>                    value = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><span class="lineno"> 3054</span>                }</div>
<div class="line"><span class="lineno"> 3055</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3056</span>            }</div>
<div class="line"><span class="lineno"> 3057</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3058</span>        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="CLI11_8hpp_source.html#l08689">App::_recognize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_a763e23060ad5d66064604003ccb689f6_icgraph.svg" width="315" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a89f81a352d3ebced093b357a351bd445" name="a89f81a352d3ebced093b357a351bd445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f81a352d3ebced093b357a351bd445">&#9670;&#160;</a></span>split_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; detail::split_names </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>current</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03075">3075</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3075</span>                                                                         {</div>
<div class="line"><span class="lineno"> 3076</span>            std::vector&lt;std::string&gt; output;</div>
<div class="line"><span class="lineno"> 3077</span>            std::size_t val = 0;</div>
<div class="line"><span class="lineno"> 3078</span>            <span class="keywordflow">while</span> ((val = current.find(<span class="charliteral">&#39;,&#39;</span>)) != std::string::npos) {</div>
<div class="line"><span class="lineno"> 3079</span>                output.push_back(trim_copy(current.substr(0, val)));</div>
<div class="line"><span class="lineno"> 3080</span>                current = current.substr(val + 1);</div>
<div class="line"><span class="lineno"> 3081</span>            }</div>
<div class="line"><span class="lineno"> 3082</span>            output.push_back(trim_copy(current));</div>
<div class="line"><span class="lineno"> 3083</span>            <span class="keywordflow">return</span> output;</div>
<div class="line"><span class="lineno"> 3084</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e6e51cf80e98374f46d05f6062a8983" name="a2e6e51cf80e98374f46d05f6062a8983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6e51cf80e98374f46d05f6062a8983">&#9670;&#160;</a></span>split_program_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; detail::split_program_name </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>commandline</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a program name and command line arguments the string is assumed to contain a file name followed by other arguments the return value contains is a pair with the first argument containing the program name and the second everything else. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l04505">4505</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 4505</span>                                                                                             {</div>
<div class="line"><span class="lineno"> 4506</span>            <span class="comment">// try to determine the programName</span></div>
<div class="line"><span class="lineno"> 4507</span>            std::pair&lt;std::string, std::string&gt; vals;</div>
<div class="line"><span class="lineno"> 4508</span>            trim(commandline);</div>
<div class="line"><span class="lineno"> 4509</span>            <span class="keyword">auto</span> esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><span class="lineno"> 4510</span>            <span class="keywordflow">while</span> (<a class="code hl_function" href="#a28a0f0282738a09f38981410f53200e9">detail::check_path</a>(commandline.substr(0, esp).c_str()) != path_type::file) {</div>
<div class="line"><span class="lineno"> 4511</span>                esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, esp + 1);</div>
<div class="line"><span class="lineno"> 4512</span>                <span class="keywordflow">if</span> (esp == std::string::npos) {</div>
<div class="line"><span class="lineno"> 4513</span>                    <span class="comment">// if we have reached the end and haven&#39;t found a valid file just assume the first argument is the</span></div>
<div class="line"><span class="lineno"> 4514</span>                    <span class="comment">// program name</span></div>
<div class="line"><span class="lineno"> 4515</span>                    <span class="keywordflow">if</span> (commandline[0] == <span class="charliteral">&#39;&quot;&#39;</span> || commandline[0] == <span class="charliteral">&#39;\&#39;&#39;</span> || commandline[0] == <span class="charliteral">&#39;`&#39;</span>) {</div>
<div class="line"><span class="lineno"> 4516</span>                        <span class="keywordtype">bool</span> embeddedQuote = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 4517</span>                        <span class="keyword">auto</span> keyChar = commandline[0];</div>
<div class="line"><span class="lineno"> 4518</span>                        <span class="keyword">auto</span> end = commandline.find_first_of(keyChar, 1);</div>
<div class="line"><span class="lineno"> 4519</span>                        <span class="keywordflow">while</span> ((end != std::string::npos) &amp;&amp; (commandline[end - 1] == <span class="charliteral">&#39;\\&#39;</span>)) { <span class="comment">// deal with escaped quotes</span></div>
<div class="line"><span class="lineno"> 4520</span>                            end = commandline.find_first_of(keyChar, end + 1);</div>
<div class="line"><span class="lineno"> 4521</span>                            embeddedQuote = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 4522</span>                        }</div>
<div class="line"><span class="lineno"> 4523</span>                        <span class="keywordflow">if</span> (end != std::string::npos) {</div>
<div class="line"><span class="lineno"> 4524</span>                            vals.first = commandline.substr(1, end - 1);</div>
<div class="line"><span class="lineno"> 4525</span>                            esp = end + 1;</div>
<div class="line"><span class="lineno"> 4526</span>                            <span class="keywordflow">if</span> (embeddedQuote) {</div>
<div class="line"><span class="lineno"> 4527</span>                                vals.first = find_and_replace(vals.first, std::string(<span class="stringliteral">&quot;\\&quot;</span>) + keyChar, std::string(1, keyChar));</div>
<div class="line"><span class="lineno"> 4528</span>                            }</div>
<div class="line"><span class="lineno"> 4529</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4530</span>                            esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><span class="lineno"> 4531</span>                        }</div>
<div class="line"><span class="lineno"> 4532</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4533</span>                        esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><span class="lineno"> 4534</span>                    }</div>
<div class="line"><span class="lineno"> 4535</span> </div>
<div class="line"><span class="lineno"> 4536</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 4537</span>                }</div>
<div class="line"><span class="lineno"> 4538</span>            }</div>
<div class="line"><span class="lineno"> 4539</span>            <span class="keywordflow">if</span> (vals.first.empty()) {</div>
<div class="line"><span class="lineno"> 4540</span>                vals.first = commandline.substr(0, esp);</div>
<div class="line"><span class="lineno"> 4541</span>                <a class="code hl_function" href="namespaceCLI_1_1detail.html#a32d84ce1a65de779e88fdf4aa3b54ea6">rtrim</a>(vals.first);</div>
<div class="line"><span class="lineno"> 4542</span>            }</div>
<div class="line"><span class="lineno"> 4543</span> </div>
<div class="line"><span class="lineno"> 4544</span>            <span class="comment">// strip the program name</span></div>
<div class="line"><span class="lineno"> 4545</span>            vals.second = (esp &lt; commandline.length() - 1) ? commandline.substr(esp + 1) : std::string{};</div>
<div class="line"><span class="lineno"> 4546</span>            <a class="code hl_function" href="namespaceCLI_1_1detail.html#aa06bf54cb3fb347d68d23d31384af42f">ltrim</a>(vals.second);</div>
<div class="line"><span class="lineno"> 4547</span>            <span class="keywordflow">return</span> vals;</div>
<div class="line"><span class="lineno"> 4548</span>        }</div>
<div class="ttc" id="anamespaceCLI_1_1detail_html_a32d84ce1a65de779e88fdf4aa3b54ea6"><div class="ttname"><a href="namespaceCLI_1_1detail.html#a32d84ce1a65de779e88fdf4aa3b54ea6">CLI::detail::rtrim</a></div><div class="ttdeci">std::string &amp; rtrim(std::string &amp;str)</div><div class="ttdoc">Trim whitespace from right of string.</div></div>
<div class="ttc" id="anamespaceCLI_1_1detail_html_aa06bf54cb3fb347d68d23d31384af42f"><div class="ttname"><a href="namespaceCLI_1_1detail.html#aa06bf54cb3fb347d68d23d31384af42f">CLI::detail::ltrim</a></div><div class="ttdeci">std::string &amp; ltrim(std::string &amp;str)</div><div class="ttdoc">Trim whitespace from left of string.</div></div>
<div class="ttc" id="anamespacedetail_html_a28a0f0282738a09f38981410f53200e9"><div class="ttname"><a href="#a28a0f0282738a09f38981410f53200e9">detail::check_path</a></div><div class="ttdeci">path_type check_path(const char *file) noexcept</div><div class="ttdoc">get the type of the path from a file name</div><div class="ttdef"><b>Definition</b> <a href="CLI11_8hpp_source.html#l04353">CLI11.hpp:4353</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CLI11_8hpp_source.html#l00628">CLI::detail::trim()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_a2e6e51cf80e98374f46d05f6062a8983_cgraph.svg" width="558" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a608a2cc4dd55857b6617e23aa3c2d7de" name="a608a2cc4dd55857b6617e23aa3c2d7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608a2cc4dd55857b6617e23aa3c2d7de">&#9670;&#160;</a></span>split_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool detail::split_short </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03036">3036</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3036</span>                                                                                                  {</div>
<div class="line"><span class="lineno"> 3037</span>            <span class="keywordflow">if</span> (current.size() &gt; 1 &amp;&amp; current[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; valid_first_char(current[1])) {</div>
<div class="line"><span class="lineno"> 3038</span>                name = current.substr(1, 1);</div>
<div class="line"><span class="lineno"> 3039</span>                rest = current.substr(2);</div>
<div class="line"><span class="lineno"> 3040</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3041</span>            }</div>
<div class="line"><span class="lineno"> 3042</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3043</span>        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="CLI11_8hpp_source.html#l09422">App::_parse_arg()</a>, and <a class="el" href="CLI11_8hpp_source.html#l08689">App::_recognize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_a608a2cc4dd55857b6617e23aa3c2d7de_icgraph.svg" width="320" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4fae90768ee6ad45ccfc0c6e9ba4aabd" name="a4fae90768ee6ad45ccfc0c6e9ba4aabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fae90768ee6ad45ccfc0c6e9ba4aabd">&#9670;&#160;</a></span>split_windows_style()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool detail::split_windows_style </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l03060">3060</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3060</span>                                                                                                           {</div>
<div class="line"><span class="lineno"> 3061</span>            <span class="keywordflow">if</span> (current.size() &gt; 1 &amp;&amp; current[0] == <span class="charliteral">&#39;/&#39;</span> &amp;&amp; valid_first_char(current[1])) {</div>
<div class="line"><span class="lineno"> 3062</span>                <span class="keyword">auto</span> loc = current.find_first_of(<span class="charliteral">&#39;:&#39;</span>);</div>
<div class="line"><span class="lineno"> 3063</span>                <span class="keywordflow">if</span> (loc != std::string::npos) {</div>
<div class="line"><span class="lineno"> 3064</span>                    name = current.substr(1, loc - 1);</div>
<div class="line"><span class="lineno"> 3065</span>                    value = current.substr(loc + 1);</div>
<div class="line"><span class="lineno"> 3066</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3067</span>                    name = current.substr(1);</div>
<div class="line"><span class="lineno"> 3068</span>                    value = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><span class="lineno"> 3069</span>                }</div>
<div class="line"><span class="lineno"> 3070</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3071</span>            }</div>
<div class="line"><span class="lineno"> 3072</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3073</span>        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="CLI11_8hpp_source.html#l09422">App::_parse_arg()</a>, and <a class="el" href="CLI11_8hpp_source.html#l08689">App::_recognize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_a4fae90768ee6ad45ccfc0c6e9ba4aabd_icgraph.svg" width="344" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa6423843bf32523b1b9888e1708528e1" name="aa6423843bf32523b1b9888e1708528e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6423843bf32523b1b9888e1708528e1">&#9670;&#160;</a></span>to_flag_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t detail::to_flag_value </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a flag into an integer value typically binary flags. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l02277">2277</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2277</span>                                                       {</div>
<div class="line"><span class="lineno"> 2278</span>            <span class="keyword">static</span> <span class="keyword">const</span> std::string trueString(<span class="stringliteral">&quot;true&quot;</span>);</div>
<div class="line"><span class="lineno"> 2279</span>            <span class="keyword">static</span> <span class="keyword">const</span> std::string falseString(<span class="stringliteral">&quot;false&quot;</span>);</div>
<div class="line"><span class="lineno"> 2280</span>            <span class="keywordflow">if</span> (val == trueString) {</div>
<div class="line"><span class="lineno"> 2281</span>                <span class="keywordflow">return</span> 1;</div>
<div class="line"><span class="lineno"> 2282</span>            }</div>
<div class="line"><span class="lineno"> 2283</span>            <span class="keywordflow">if</span> (val == falseString) {</div>
<div class="line"><span class="lineno"> 2284</span>                <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="lineno"> 2285</span>            }</div>
<div class="line"><span class="lineno"> 2286</span>            val = detail::to_lower(val);</div>
<div class="line"><span class="lineno"> 2287</span>            std::int64_t ret = 0;</div>
<div class="line"><span class="lineno"> 2288</span>            <span class="keywordflow">if</span> (val.size() == 1) {</div>
<div class="line"><span class="lineno"> 2289</span>                <span class="keywordflow">if</span> (val[0] &gt;= <span class="charliteral">&#39;1&#39;</span> &amp;&amp; val[0] &lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line"><span class="lineno"> 2290</span>                    <span class="keywordflow">return</span> (<span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(val[0]) - <span class="charliteral">&#39;0&#39;</span>);</div>
<div class="line"><span class="lineno"> 2291</span>                }</div>
<div class="line"><span class="lineno"> 2292</span>                <span class="keywordflow">switch</span> (val[0]) {</div>
<div class="line"><span class="lineno"> 2293</span>                    <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:</div>
<div class="line"><span class="lineno"> 2294</span>                    <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>:</div>
<div class="line"><span class="lineno"> 2295</span>                    <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>:</div>
<div class="line"><span class="lineno"> 2296</span>                    <span class="keywordflow">case</span> <span class="charliteral">&#39;-&#39;</span>:</div>
<div class="line"><span class="lineno"> 2297</span>                        ret = -1;</div>
<div class="line"><span class="lineno"> 2298</span>                        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2299</span>                    <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>:</div>
<div class="line"><span class="lineno"> 2300</span>                    <span class="keywordflow">case</span> <span class="charliteral">&#39;y&#39;</span>:</div>
<div class="line"><span class="lineno"> 2301</span>                    <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>:</div>
<div class="line"><span class="lineno"> 2302</span>                        ret = 1;</div>
<div class="line"><span class="lineno"> 2303</span>                        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2304</span>                    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno"> 2305</span>                        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;unrecognized character&quot;</span>);</div>
<div class="line"><span class="lineno"> 2306</span>                }</div>
<div class="line"><span class="lineno"> 2307</span>                <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno"> 2308</span>            }</div>
<div class="line"><span class="lineno"> 2309</span>            <span class="keywordflow">if</span> (val == trueString || val == <span class="stringliteral">&quot;on&quot;</span> || val == <span class="stringliteral">&quot;yes&quot;</span> || val == <span class="stringliteral">&quot;enable&quot;</span>) {</div>
<div class="line"><span class="lineno"> 2310</span>                ret = 1;</div>
<div class="line"><span class="lineno"> 2311</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val == falseString || val == <span class="stringliteral">&quot;off&quot;</span> || val == <span class="stringliteral">&quot;no&quot;</span> || val == <span class="stringliteral">&quot;disable&quot;</span>) {</div>
<div class="line"><span class="lineno"> 2312</span>                ret = -1;</div>
<div class="line"><span class="lineno"> 2313</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2314</span>                ret = std::stoll(val);</div>
<div class="line"><span class="lineno"> 2315</span>            }</div>
<div class="line"><span class="lineno"> 2316</span>            <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno"> 2317</span>        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CLI11_8hpp_source.html#l00702">CLI::detail::to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CLI11_8hpp_source.html#l05939">Option::get_flag_value()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_aa6423843bf32523b1b9888e1708528e1_cgraph.svg" width="364" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacedetail_aa6423843bf32523b1b9888e1708528e1_icgraph.svg" width="383" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a93a646f04f5f3a4daecc475404a93fb5" name="a93a646f04f5f3a4daecc475404a93fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a646f04f5f3a4daecc475404a93fb5">&#9670;&#160;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a string from the object. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01673">1673</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1673</span>                                            {</div>
<div class="line"><span class="lineno"> 1674</span>            <span class="keywordflow">return</span> std::string(value); <span class="comment">// NOLINT(google-readability-casting)</span></div>
<div class="line"><span class="lineno"> 1675</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af260ade0bc2785a1cad438e74e84c665" name="af260ade0bc2785a1cad438e74e84c665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af260ade0bc2785a1cad438e74e84c665">&#9670;&#160;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;<a class="el" href="classdetail_1_1is__ostreamable.html">is_ostreamable</a>&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (streaming must be supported for that type) </p>
<p>convert a readable container to a string</p>
<p>If conversion is not supported, return an empty string (streaming is not supported for that type) </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01682">1682</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1682</span>                                       {</div>
<div class="line"><span class="lineno"> 1683</span>            std::stringstream stream;</div>
<div class="line"><span class="lineno"> 1684</span>            stream &lt;&lt; value;</div>
<div class="line"><span class="lineno"> 1685</span>            <span class="keywordflow">return</span> stream.str();</div>
<div class="line"><span class="lineno"> 1686</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aacf2ca1139f2ebed02bdfd71de954815" name="aacf2ca1139f2ebed02bdfd71de954815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf2ca1139f2ebed02bdfd71de954815">&#9670;&#160;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_convertible&lt; T, std::string &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; decltype(std::forward&lt;T&gt;(value)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (directly forward if this can become a string) </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01665">1665</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1665</span>                                                                    {</div>
<div class="line"><span class="lineno"> 1666</span>            <span class="keywordflow">return</span> std::forward&lt;T&gt;(value);</div>
<div class="line"><span class="lineno"> 1667</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9bec111d9f18677e64ece6787a824f21" name="a9bec111d9f18677e64ece6787a824f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bec111d9f18677e64ece6787a824f21">&#9670;&#160;</a></span>tuple_type_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; I==<a class="el" href="structdetail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type detail::tuple_type_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0 if the index &gt; tuple size </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01826">1826</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1826</span>                                                                                                 {</div>
<div class="line"><span class="lineno"> 1827</span>            <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno"> 1828</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8ed3e17654a22e52c65af40d1c99af7" name="aa8ed3e17654a22e52c65af40d1c99af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ed3e17654a22e52c65af40d1c99af7">&#9670;&#160;</a></span>value_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt; std::is_arithmetic&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a string as a convertible value for arithmetic types </p>
<p>get a string as a convertible value for enumerations </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01728">1728</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1728</span>                                               {</div>
<div class="line"><span class="lineno"> 1729</span>            <span class="keywordflow">return</span> std::to_string(value);</div>
<div class="line"><span class="lineno"> 1730</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a49a9010bd9c361218bf65a0de139d8d3" name="a49a9010bd9c361218bf65a0de139d8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a9010bd9c361218bf65a0de139d8d3">&#9670;&#160;</a></span>value_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="CLI11_8hpp.html#a012819c9e8b5e04872a271f50f8b8196">enable_if_t</a>&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, <a class="el" href="#ad86f32fac98b29b6cae34669baea3710">detail::enabler</a> &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="#aacf2ca1139f2ebed02bdfd71de954815">to_string</a>(value)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for other types just use the regular to_string function </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01738">1738</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1738</span>                                                                        {</div>
<div class="line"><span class="lineno"> 1739</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="#aacf2ca1139f2ebed02bdfd71de954815">to_string</a>(value);</div>
<div class="line"><span class="lineno"> 1740</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7dcea5f3938db14745073fd1fdbe4d85" name="a7dcea5f3938db14745073fd1fdbe4d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcea5f3938db14745073fd1fdbe4d85">&#9670;&#160;</a></span>dummy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad86f32fac98b29b6cae34669baea3710">enabler</a> detail::dummy = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An instance to use in EnableIf. </p>

<p class="definition">Definition at line <a class="el" href="CLI11_8hpp_source.html#l01377">1377</a> of file <a class="el" href="CLI11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1377</span>{};</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedetail.html">detail</a></li>
    <li class="footer">Generated on Sun Jan 5 2025 00:54:59 for SNode.C by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
